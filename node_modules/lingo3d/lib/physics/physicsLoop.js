import { createEffect } from "@lincode/reactivity";
import { world } from "./physicsWorld";
import { getPhysics } from "../states/usePhysics";
import { loop } from "../engine/eventLoop";
import { forceGet } from "@lincode/utils";
export const physicsSet = new Set();
export const physicsContactMap = new Map();
export const physicsContactBodies = new WeakSet();
const makeWeakSet = () => new WeakSet();
const dt = 1 / 60;
createEffect(() => {
    const physics = getPhysics();
    if (!physics)
        return;
    const handle = loop(() => {
        for (const item of physicsSet) {
            const body = item.physicsBody;
            if (item._mAV) {
                const { x, y, z } = item._mAV;
                const { angularVelocity } = body;
                if (angularVelocity.x > x)
                    angularVelocity.x = x;
                else if (angularVelocity.x < -x)
                    angularVelocity.x = -x;
                if (angularVelocity.y > y)
                    angularVelocity.y = y;
                else if (angularVelocity.y < -y)
                    angularVelocity.y = -y;
                if (angularVelocity.z > z)
                    angularVelocity.z = z;
                else if (angularVelocity.z < -z)
                    angularVelocity.z = -z;
            }
            if (item._mV) {
                const { x, y, z } = item._mV;
                const { velocity } = body;
                if (velocity.x > x)
                    velocity.x = x;
                else if (velocity.x < -x)
                    velocity.x = -x;
                if (velocity.y > y)
                    velocity.y = y;
                else if (velocity.y < -y)
                    velocity.y = -y;
                if (velocity.z > z)
                    velocity.z = z;
                else if (velocity.z < -z)
                    velocity.z = -z;
            }
            //@ts-ignore
            const { position, rotation } = item.physicsUpdate;
            //@ts-ignore
            item.physicsUpdate = {};
            if (position) {
                if (position.x) {
                    body.position.x = item.outerObject3d.position.x;
                    body.velocity.x = 0;
                    body.force.x = 0;
                }
                if (position.y) {
                    body.position.y = item.outerObject3d.position.y;
                    body.velocity.y = 0;
                    body.force.y = 0;
                }
                if (position.z) {
                    body.position.z = item.outerObject3d.position.z;
                    body.velocity.z = 0;
                    body.force.z = 0;
                }
            }
            //@ts-ignore
            item.outerObject3d.position.copy(body.position);
            if (rotation) {
                if (rotation.x) {
                    body.angularVelocity.x = 0;
                    body.torque.x = 0;
                }
                if (rotation.y) {
                    body.angularVelocity.y = 0;
                    body.torque.y = 0;
                }
                if (rotation.z) {
                    body.angularVelocity.z = 0;
                    body.torque.z = 0;
                }
                //@ts-ignore
                body.quaternion.copy(item.outerObject3d.quaternion);
            }
            //@ts-ignore
            else
                item.outerObject3d.quaternion.copy(body.quaternion);
        }
        world.step(dt);
        physicsContactMap.clear();
        for (const contact of world.contacts)
            forceGet(physicsContactMap, contact.bi, makeWeakSet).add(contact.bj);
    });
    return () => {
        handle.cancel();
    };
}, [getPhysics]);

import {
  AmbientLight_default,
  AreaLight_default,
  Camera,
  Circle,
  Cone,
  Cube,
  Cylinder,
  DirectionalLight_default,
  Group,
  Keyboard,
  Model,
  Mouse,
  Octahedron,
  OrbitCamera_default,
  Plane,
  PointLight_default,
  Reflector,
  Scene,
  SkyLight_default,
  Skybox,
  Sphere,
  SpotLight_default,
  Sprite_default,
  SvgMesh_default,
  Tetrahedron,
  ThirdPersonCamera,
  Torus,
  applySetup_default,
  container,
  distance,
  endPoint,
  lib_default,
  loop,
  outline,
  rad2Deg,
  require_lib,
  settings_default
} from "./chunk-WXDWBIFR.js";
import {
  require_react
} from "./chunk-M6H7GHRE.js";
import {
  Cancellable,
  Resolvable,
  forceGet,
  isGlobalState,
  preventTreeShake,
  store
} from "./chunk-VKNJNY6E.js";
import "./chunk-FRBAMVNO.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-LVG27HH2.js";

// node_modules/lingo3d-react/lib/components/World.js
var import_react = __toESM(require_react());
preventTreeShake(lib_default);
outline.style.display = "none";
var World = (_a) => {
  var _b = _a, { style, children } = _b, rest = __objRest(_b, ["style", "children"]);
  const divRef = (0, import_react.useRef)(null);
  (0, import_react.useLayoutEffect)(() => {
    const el = divRef.current;
    if (!el)
      return;
    el.appendChild(container);
    const cb2 = () => {
      settings_default.containerWidth = settings_default.width = el.clientWidth;
      settings_default.containerHeight = settings_default.height = el.clientHeight;
    };
    cb2();
    window.addEventListener("resize", cb2);
    return () => {
      window.removeEventListener("resize", cb2);
    };
  }, []);
  return import_react.default.createElement("div", __spreadProps(__spreadValues({ ref: divRef }, rest), { style: __spreadValues({ width: "100%", height: "100%", position: "absolute", top: 0, left: 0 }, style) }), children);
};
var World_default = World;

// node_modules/lingo3d-react/lib/components/api/Keyboard.js
var import_react20 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/useManager.js
var import_react19 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/useDiffProps.js
var import_react2 = __toESM(require_react());
var useDiffProps_default = (props) => {
  const propsOldRef = (0, import_react2.useRef)({});
  const propsOld = propsOldRef.current;
  const changes = [];
  for (const [key, value] of Object.entries(props)) {
    const valueOld = propsOld[key];
    if (valueOld === value)
      continue;
    if (value && typeof value === "object") {
      if (JSON.stringify(value) !== JSON.stringify(valueOld))
        changes.push([key, value]);
    } else
      changes.push([key, value]);
  }
  propsOldRef.current = props;
  return changes;
};

// node_modules/@lincode/hooks/lib/useTruthy.js
var import_react3 = __toESM(require_react());
var useTruthy_default = (value, condition) => {
  const ref = (0, import_react3.useRef)();
  if (condition === void 0)
    value && (ref.current = value);
  else
    condition && (ref.current = value);
  return ref.current;
};

// node_modules/@lincode/hooks/lib/useWindowSize.js
var import_react4 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useFileDrop.js
var import_react5 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useTimeout.js
var import_react6 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useCurrentRef.js
var import_react7 = __toESM(require_react());
var useCurrentRef_default = (value) => {
  const ref = (0, import_react7.useRef)(value);
  ref.current = value;
  return ref;
};

// node_modules/@lincode/hooks/lib/useMemoOnce.js
var import_react8 = __toESM(require_react());
var log = console.log;
var cache = [];
var useMemoOnce_default = (factory) => {
  return (0, import_react8.useMemo)(() => {
    if (log === console.log) {
      queueMicrotask(() => cache = []);
      const result = factory();
      cache.push(result);
      return result;
    }
    return cache.shift();
  }, []);
};

// node_modules/@lincode/hooks/lib/useDebounce.js
var import_react9 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useDebounceEffect.js
var import_react10 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/usePrevious.js
var import_react11 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useResizeObserver.js
var import_react12 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useVisibilityObserver.js
var import_react13 = __toESM(require_react());

// node_modules/intersection-observer/intersection-observer.js
(function() {
  "use strict";
  if (typeof window !== "object") {
    return;
  }
  if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
    if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get: function() {
          return this.intersectionRatio > 0;
        }
      });
    }
    return;
  }
  function getFrameElement(doc) {
    try {
      return doc.defaultView && doc.defaultView.frameElement || null;
    } catch (e) {
      return null;
    }
  }
  var document2 = function(startDoc) {
    var doc = startDoc;
    var frame2 = getFrameElement(doc);
    while (frame2) {
      doc = frame2.ownerDocument;
      frame2 = getFrameElement(doc);
    }
    return doc;
  }(window.document);
  var registry = [];
  var crossOriginUpdater = null;
  var crossOriginRect = null;
  function IntersectionObserverEntry(entry) {
    this.time = entry.time;
    this.target = entry.target;
    this.rootBounds = ensureDOMRect(entry.rootBounds);
    this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
    this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
    this.isIntersecting = !!entry.intersectionRect;
    var targetRect = this.boundingClientRect;
    var targetArea = targetRect.width * targetRect.height;
    var intersectionRect = this.intersectionRect;
    var intersectionArea = intersectionRect.width * intersectionRect.height;
    if (targetArea) {
      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
    } else {
      this.intersectionRatio = this.isIntersecting ? 1 : 0;
    }
  }
  function IntersectionObserver2(callback, opt_options) {
    var options = opt_options || {};
    if (typeof callback != "function") {
      throw new Error("callback must be a function");
    }
    if (options.root && options.root.nodeType != 1 && options.root.nodeType != 9) {
      throw new Error("root must be a Document or Element");
    }
    this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
    this._callback = callback;
    this._observationTargets = [];
    this._queuedEntries = [];
    this._rootMarginValues = this._parseRootMargin(options.rootMargin);
    this.thresholds = this._initThresholds(options.threshold);
    this.root = options.root || null;
    this.rootMargin = this._rootMarginValues.map(function(margin) {
      return margin.value + margin.unit;
    }).join(" ");
    this._monitoringDocuments = [];
    this._monitoringUnsubscribes = [];
  }
  IntersectionObserver2.prototype.THROTTLE_TIMEOUT = 100;
  IntersectionObserver2.prototype.POLL_INTERVAL = null;
  IntersectionObserver2.prototype.USE_MUTATION_OBSERVER = true;
  IntersectionObserver2._setupCrossOriginUpdater = function() {
    if (!crossOriginUpdater) {
      crossOriginUpdater = function(boundingClientRect, intersectionRect) {
        if (!boundingClientRect || !intersectionRect) {
          crossOriginRect = getEmptyRect();
        } else {
          crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
        }
        registry.forEach(function(observer) {
          observer._checkForIntersections();
        });
      };
    }
    return crossOriginUpdater;
  };
  IntersectionObserver2._resetCrossOriginUpdater = function() {
    crossOriginUpdater = null;
    crossOriginRect = null;
  };
  IntersectionObserver2.prototype.observe = function(target) {
    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
      return item.element == target;
    });
    if (isTargetAlreadyObserved) {
      return;
    }
    if (!(target && target.nodeType == 1)) {
      throw new Error("target must be an Element");
    }
    this._registerInstance();
    this._observationTargets.push({ element: target, entry: null });
    this._monitorIntersections(target.ownerDocument);
    this._checkForIntersections();
  };
  IntersectionObserver2.prototype.unobserve = function(target) {
    this._observationTargets = this._observationTargets.filter(function(item) {
      return item.element != target;
    });
    this._unmonitorIntersections(target.ownerDocument);
    if (this._observationTargets.length == 0) {
      this._unregisterInstance();
    }
  };
  IntersectionObserver2.prototype.disconnect = function() {
    this._observationTargets = [];
    this._unmonitorAllIntersections();
    this._unregisterInstance();
  };
  IntersectionObserver2.prototype.takeRecords = function() {
    var records = this._queuedEntries.slice();
    this._queuedEntries = [];
    return records;
  };
  IntersectionObserver2.prototype._initThresholds = function(opt_threshold) {
    var threshold = opt_threshold || [0];
    if (!Array.isArray(threshold))
      threshold = [threshold];
    return threshold.sort().filter(function(t, i, a) {
      if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
        throw new Error("threshold must be a number between 0 and 1 inclusively");
      }
      return t !== a[i - 1];
    });
  };
  IntersectionObserver2.prototype._parseRootMargin = function(opt_rootMargin) {
    var marginString = opt_rootMargin || "0px";
    var margins = marginString.split(/\s+/).map(function(margin) {
      var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
      if (!parts) {
        throw new Error("rootMargin must be specified in pixels or percent");
      }
      return { value: parseFloat(parts[1]), unit: parts[2] };
    });
    margins[1] = margins[1] || margins[0];
    margins[2] = margins[2] || margins[0];
    margins[3] = margins[3] || margins[1];
    return margins;
  };
  IntersectionObserver2.prototype._monitorIntersections = function(doc) {
    var win = doc.defaultView;
    if (!win) {
      return;
    }
    if (this._monitoringDocuments.indexOf(doc) != -1) {
      return;
    }
    var callback = this._checkForIntersections;
    var monitoringInterval = null;
    var domObserver = null;
    if (this.POLL_INTERVAL) {
      monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
    } else {
      addEvent(win, "resize", callback, true);
      addEvent(doc, "scroll", callback, true);
      if (this.USE_MUTATION_OBSERVER && "MutationObserver" in win) {
        domObserver = new win.MutationObserver(callback);
        domObserver.observe(doc, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
    this._monitoringDocuments.push(doc);
    this._monitoringUnsubscribes.push(function() {
      var win2 = doc.defaultView;
      if (win2) {
        if (monitoringInterval) {
          win2.clearInterval(monitoringInterval);
        }
        removeEvent(win2, "resize", callback, true);
      }
      removeEvent(doc, "scroll", callback, true);
      if (domObserver) {
        domObserver.disconnect();
      }
    });
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    if (doc != rootDoc) {
      var frame2 = getFrameElement(doc);
      if (frame2) {
        this._monitorIntersections(frame2.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorIntersections = function(doc) {
    var index = this._monitoringDocuments.indexOf(doc);
    if (index == -1) {
      return;
    }
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    var hasDependentTargets = this._observationTargets.some(function(item) {
      var itemDoc = item.element.ownerDocument;
      if (itemDoc == doc) {
        return true;
      }
      while (itemDoc && itemDoc != rootDoc) {
        var frame3 = getFrameElement(itemDoc);
        itemDoc = frame3 && frame3.ownerDocument;
        if (itemDoc == doc) {
          return true;
        }
      }
      return false;
    });
    if (hasDependentTargets) {
      return;
    }
    var unsubscribe = this._monitoringUnsubscribes[index];
    this._monitoringDocuments.splice(index, 1);
    this._monitoringUnsubscribes.splice(index, 1);
    unsubscribe();
    if (doc != rootDoc) {
      var frame2 = getFrameElement(doc);
      if (frame2) {
        this._unmonitorIntersections(frame2.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorAllIntersections = function() {
    var unsubscribes = this._monitoringUnsubscribes.slice(0);
    this._monitoringDocuments.length = 0;
    this._monitoringUnsubscribes.length = 0;
    for (var i = 0; i < unsubscribes.length; i++) {
      unsubscribes[i]();
    }
  };
  IntersectionObserver2.prototype._checkForIntersections = function() {
    if (!this.root && crossOriginUpdater && !crossOriginRect) {
      return;
    }
    var rootIsInDom = this._rootIsInDom();
    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
    this._observationTargets.forEach(function(item) {
      var target = item.element;
      var targetRect = getBoundingClientRect(target);
      var rootContainsTarget = this._rootContainsTarget(target);
      var oldEntry = item.entry;
      var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, targetRect, rootRect);
      var rootBounds = null;
      if (!this._rootContainsTarget(target)) {
        rootBounds = getEmptyRect();
      } else if (!crossOriginUpdater || this.root) {
        rootBounds = rootRect;
      }
      var newEntry = item.entry = new IntersectionObserverEntry({
        time: now(),
        target,
        boundingClientRect: targetRect,
        rootBounds,
        intersectionRect
      });
      if (!oldEntry) {
        this._queuedEntries.push(newEntry);
      } else if (rootIsInDom && rootContainsTarget) {
        if (this._hasCrossedThreshold(oldEntry, newEntry)) {
          this._queuedEntries.push(newEntry);
        }
      } else {
        if (oldEntry && oldEntry.isIntersecting) {
          this._queuedEntries.push(newEntry);
        }
      }
    }, this);
    if (this._queuedEntries.length) {
      this._callback(this.takeRecords(), this);
    }
  };
  IntersectionObserver2.prototype._computeTargetAndRootIntersection = function(target, targetRect, rootRect) {
    if (window.getComputedStyle(target).display == "none")
      return;
    var intersectionRect = targetRect;
    var parent = getParentNode(target);
    var atRoot = false;
    while (!atRoot && parent) {
      var parentRect = null;
      var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {};
      if (parentComputedStyle.display == "none")
        return null;
      if (parent == this.root || parent.nodeType == 9) {
        atRoot = true;
        if (parent == this.root || parent == document2) {
          if (crossOriginUpdater && !this.root) {
            if (!crossOriginRect || crossOriginRect.width == 0 && crossOriginRect.height == 0) {
              parent = null;
              parentRect = null;
              intersectionRect = null;
            } else {
              parentRect = crossOriginRect;
            }
          } else {
            parentRect = rootRect;
          }
        } else {
          var frame2 = getParentNode(parent);
          var frameRect = frame2 && getBoundingClientRect(frame2);
          var frameIntersect = frame2 && this._computeTargetAndRootIntersection(frame2, frameRect, rootRect);
          if (frameRect && frameIntersect) {
            parent = frame2;
            parentRect = convertFromParentRect(frameRect, frameIntersect);
          } else {
            parent = null;
            intersectionRect = null;
          }
        }
      } else {
        var doc = parent.ownerDocument;
        if (parent != doc.body && parent != doc.documentElement && parentComputedStyle.overflow != "visible") {
          parentRect = getBoundingClientRect(parent);
        }
      }
      if (parentRect) {
        intersectionRect = computeRectIntersection(parentRect, intersectionRect);
      }
      if (!intersectionRect)
        break;
      parent = parent && getParentNode(parent);
    }
    return intersectionRect;
  };
  IntersectionObserver2.prototype._getRootRect = function() {
    var rootRect;
    if (this.root && !isDoc(this.root)) {
      rootRect = getBoundingClientRect(this.root);
    } else {
      var doc = isDoc(this.root) ? this.root : document2;
      var html = doc.documentElement;
      var body = doc.body;
      rootRect = {
        top: 0,
        left: 0,
        right: html.clientWidth || body.clientWidth,
        width: html.clientWidth || body.clientWidth,
        bottom: html.clientHeight || body.clientHeight,
        height: html.clientHeight || body.clientHeight
      };
    }
    return this._expandRectByRootMargin(rootRect);
  };
  IntersectionObserver2.prototype._expandRectByRootMargin = function(rect) {
    var margins = this._rootMarginValues.map(function(margin, i) {
      return margin.unit == "px" ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100;
    });
    var newRect = {
      top: rect.top - margins[0],
      right: rect.right + margins[1],
      bottom: rect.bottom + margins[2],
      left: rect.left - margins[3]
    };
    newRect.width = newRect.right - newRect.left;
    newRect.height = newRect.bottom - newRect.top;
    return newRect;
  };
  IntersectionObserver2.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {
    var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
    var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
    if (oldRatio === newRatio)
      return;
    for (var i = 0; i < this.thresholds.length; i++) {
      var threshold = this.thresholds[i];
      if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
        return true;
      }
    }
  };
  IntersectionObserver2.prototype._rootIsInDom = function() {
    return !this.root || containsDeep(document2, this.root);
  };
  IntersectionObserver2.prototype._rootContainsTarget = function(target) {
    var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
    return containsDeep(rootDoc, target) && (!this.root || rootDoc == target.ownerDocument);
  };
  IntersectionObserver2.prototype._registerInstance = function() {
    if (registry.indexOf(this) < 0) {
      registry.push(this);
    }
  };
  IntersectionObserver2.prototype._unregisterInstance = function() {
    var index = registry.indexOf(this);
    if (index != -1)
      registry.splice(index, 1);
  };
  function now() {
    return window.performance && performance.now && performance.now();
  }
  function throttle(fn, timeout) {
    var timer = null;
    return function() {
      if (!timer) {
        timer = setTimeout(function() {
          fn();
          timer = null;
        }, timeout);
      }
    };
  }
  function addEvent(node, event, fn, opt_useCapture) {
    if (typeof node.addEventListener == "function") {
      node.addEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node.attachEvent == "function") {
      node.attachEvent("on" + event, fn);
    }
  }
  function removeEvent(node, event, fn, opt_useCapture) {
    if (typeof node.removeEventListener == "function") {
      node.removeEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node.detatchEvent == "function") {
      node.detatchEvent("on" + event, fn);
    }
  }
  function computeRectIntersection(rect1, rect2) {
    var top = Math.max(rect1.top, rect2.top);
    var bottom = Math.min(rect1.bottom, rect2.bottom);
    var left = Math.max(rect1.left, rect2.left);
    var right = Math.min(rect1.right, rect2.right);
    var width = right - left;
    var height = bottom - top;
    return width >= 0 && height >= 0 && {
      top,
      bottom,
      left,
      right,
      width,
      height
    } || null;
  }
  function getBoundingClientRect(el) {
    var rect;
    try {
      rect = el.getBoundingClientRect();
    } catch (err) {
    }
    if (!rect)
      return getEmptyRect();
    if (!(rect.width && rect.height)) {
      rect = {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };
    }
    return rect;
  }
  function getEmptyRect() {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  function ensureDOMRect(rect) {
    if (!rect || "x" in rect) {
      return rect;
    }
    return {
      top: rect.top,
      y: rect.top,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      right: rect.right,
      width: rect.width,
      height: rect.height
    };
  }
  function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
    var top = parentIntersectionRect.top - parentBoundingRect.top;
    var left = parentIntersectionRect.left - parentBoundingRect.left;
    return {
      top,
      left,
      height: parentIntersectionRect.height,
      width: parentIntersectionRect.width,
      bottom: top + parentIntersectionRect.height,
      right: left + parentIntersectionRect.width
    };
  }
  function containsDeep(parent, child) {
    var node = child;
    while (node) {
      if (node == parent)
        return true;
      node = getParentNode(node);
    }
    return false;
  }
  function getParentNode(node) {
    var parent = node.parentNode;
    if (node.nodeType == 9 && node != document2) {
      return getFrameElement(node);
    }
    if (parent && parent.assignedSlot) {
      parent = parent.assignedSlot.parentNode;
    }
    if (parent && parent.nodeType == 11 && parent.host) {
      return parent.host;
    }
    return parent;
  }
  function isDoc(node) {
    return node && node.nodeType === 9;
  }
  window.IntersectionObserver = IntersectionObserver2;
  window.IntersectionObserverEntry = IntersectionObserverEntry;
})();

// node_modules/@lincode/hooks/lib/useClickOutside.js
var import_react14 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useClick.js
var import_react15 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useScroll.js
var import_react16 = __toESM(require_react());

// node_modules/@lincode/hooks/lib/useAspectRatio.js
var import_react17 = __toESM(require_react());

// node_modules/lingo3d-react/lib/components/display/Scene.js
var import_react18 = __toESM(require_react());
var SceneContext = import_react18.default.createContext(void 0);
var Scene2 = import_react18.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Scene);
  return import_react18.default.createElement(SceneContext.Provider, { value: manager }, import_react18.default.createElement(ParentContext.Provider, { value: manager }, p.children));
});
var Scene_default = Scene2;

// node_modules/lingo3d-react/lib/hooks/useManager.js
var ParentContext = import_react19.default.createContext(void 0);
var handleStore = /* @__PURE__ */ new WeakMap();
var useManager_default = (p, ref, ManagerClass) => {
  var _a;
  const _a2 = p, { children } = _a2, props = __objRest(_a2, ["children"]);
  const parent = (0, import_react19.useContext)(ParentContext);
  const scene = (0, import_react19.useContext)(SceneContext);
  const manager = useMemoOnce_default(() => {
    const manager2 = new ManagerClass();
    parent === null || parent === void 0 ? void 0 : parent.append(manager2);
    return manager2;
  });
  const changed = useDiffProps_default(props);
  for (const [key, value] of changed) {
    const handleMap = forceGet(handleStore, manager, () => /* @__PURE__ */ new Map());
    (_a = handleMap.get(key)) === null || _a === void 0 ? void 0 : _a.cancel();
    if (isGlobalState(value)) {
      handleMap.set(key, value((v) => manager[key] = v));
      continue;
    } else if (key === "physics" && scene) {
      handleMap.set(key, scene.loadedResolvable.then(() => manager.physics = value));
      continue;
    }
    manager[key] = value;
  }
  (0, import_react19.useLayoutEffect)(() => {
    return () => {
      const handleMap = handleStore.get(manager);
      if (handleMap)
        for (const handle of handleMap.values())
          handle.cancel();
      manager.dispose();
    };
  }, []);
  (0, import_react19.useLayoutEffect)(() => {
    if (!ref)
      return;
    if (typeof ref === "function")
      ref(manager);
    else
      ref.current = manager;
  }, [ref]);
  return manager;
};

// node_modules/lingo3d-react/lib/components/api/Keyboard.js
var Keyboard2 = import_react20.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Keyboard);
  return import_react20.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Keyboard_default = Keyboard2;

// node_modules/lingo3d-react/lib/components/api/Mouse.js
var import_react21 = __toESM(require_react());
var Mouse2 = import_react21.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Mouse);
  return import_react21.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Mouse_default = Mouse2;

// node_modules/lingo3d-react/lib/components/display/Group.js
var import_react22 = __toESM(require_react());
var Group2 = import_react22.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Group);
  return import_react22.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Group_default = Group2;

// node_modules/lingo3d-react/lib/components/display/Model.js
var import_react23 = __toESM(require_react());
var Model2 = import_react23.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Model);
  return import_react23.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Model_default = Model2;

// node_modules/lingo3d-react/lib/components/display/Reflector.js
var import_react24 = __toESM(require_react());
var Reflector2 = import_react24.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Reflector);
  return import_react24.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Reflector_default = Reflector2;

// node_modules/lingo3d-react/lib/components/display/Skybox.js
var import_react25 = __toESM(require_react());
var Skybox2 = import_react25.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Skybox);
  return import_react25.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Skybox_default = Skybox2;

// node_modules/lingo3d-react/lib/components/display/Sprite.js
var import_react26 = __toESM(require_react());
var Sprite = import_react26.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Sprite_default);
  return import_react26.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Sprite_default2 = Sprite;

// node_modules/lingo3d-react/lib/components/display/SvgMesh.js
var import_react27 = __toESM(require_react());
var SvgMesh = import_react27.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, SvgMesh_default);
  return import_react27.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var SvgMesh_default2 = SvgMesh;

// node_modules/lingo3d-react/lib/components/display/cameras/Camera.js
var import_react28 = __toESM(require_react());
var Camera2 = import_react28.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Camera);
  return import_react28.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Camera_default = Camera2;

// node_modules/lingo3d-react/lib/components/display/cameras/OrbitCamera.js
var import_react29 = __toESM(require_react());
var OrbitCamera = import_react29.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, OrbitCamera_default);
  return import_react29.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var OrbitCamera_default2 = OrbitCamera;

// node_modules/lingo3d-react/lib/components/display/cameras/ThirdPersonCamera.js
var import_react30 = __toESM(require_react());
var ThirdPersonCamera2 = import_react30.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, ThirdPersonCamera);
  return import_react30.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var ThirdPersonCamera_default = ThirdPersonCamera2;

// node_modules/lingo3d-react/lib/components/display/lights/AmbientLight.js
var import_react31 = __toESM(require_react());
var AmbientLight = import_react31.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, AmbientLight_default);
  return import_react31.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var AmbientLight_default2 = AmbientLight;

// node_modules/lingo3d-react/lib/components/display/lights/AreaLight.js
var import_react32 = __toESM(require_react());
var AreaLight = import_react32.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, AreaLight_default);
  return import_react32.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var AreaLight_default2 = AreaLight;

// node_modules/lingo3d-react/lib/components/display/lights/DirectionalLight.js
var import_react33 = __toESM(require_react());
var DirectionalLight = import_react33.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, DirectionalLight_default);
  return import_react33.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var DirectionalLight_default2 = DirectionalLight;

// node_modules/lingo3d-react/lib/components/display/lights/PointLight.js
var import_react34 = __toESM(require_react());
var PointLight = import_react34.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, PointLight_default);
  return import_react34.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var PointLight_default2 = PointLight;

// node_modules/lingo3d-react/lib/components/display/lights/SkyLight.js
var import_react35 = __toESM(require_react());
var SkyLight = import_react35.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, SkyLight_default);
  return import_react35.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var SkyLight_default2 = SkyLight;

// node_modules/lingo3d-react/lib/components/display/lights/SpotLight.js
var import_react36 = __toESM(require_react());
var SpotLight = import_react36.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, SpotLight_default);
  return import_react36.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var SpotLight_default2 = SpotLight;

// node_modules/lingo3d-react/lib/components/display/primitives/Circle.js
var import_react37 = __toESM(require_react());
var Circle2 = import_react37.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Circle);
  return import_react37.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Circle_default = Circle2;

// node_modules/lingo3d-react/lib/components/display/primitives/Cone.js
var import_react38 = __toESM(require_react());
var Cone2 = import_react38.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Cone);
  return import_react38.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Cone_default = Cone2;

// node_modules/lingo3d-react/lib/components/display/primitives/Cube.js
var import_react39 = __toESM(require_react());
var Cube2 = import_react39.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Cube);
  return import_react39.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Cube_default = Cube2;

// node_modules/lingo3d-react/lib/components/display/primitives/Cylinder.js
var import_react40 = __toESM(require_react());
var Cylinder2 = import_react40.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Cylinder);
  return import_react40.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Cylinder_default = Cylinder2;

// node_modules/lingo3d-react/lib/components/display/primitives/Octahedron.js
var import_react41 = __toESM(require_react());
var Octahedron2 = import_react41.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Octahedron);
  return import_react41.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Octahedron_default = Octahedron2;

// node_modules/lingo3d-react/lib/components/display/primitives/Plane.js
var import_react42 = __toESM(require_react());
var Plane2 = import_react42.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Plane);
  return import_react42.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Plane_default = Plane2;

// node_modules/lingo3d-react/lib/components/display/primitives/Sphere.js
var import_react43 = __toESM(require_react());
var Sphere2 = import_react43.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Sphere);
  return import_react43.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Sphere_default = Sphere2;

// node_modules/lingo3d-react/lib/components/display/primitives/Tetrahedron.js
var import_react44 = __toESM(require_react());
var Tetrahedron2 = import_react44.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Tetrahedron);
  return import_react44.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Tetrahedron_default = Tetrahedron2;

// node_modules/lingo3d-react/lib/components/display/primitives/Torus.js
var import_react45 = __toESM(require_react());
var Torus2 = import_react45.default.forwardRef((p, ref) => {
  const manager = useManager_default(p, ref, Torus);
  return import_react45.default.createElement(ParentContext.Provider, { value: manager }, p.children);
});
var Torus_default = Torus2;

// node_modules/lingo3d-react/lib/components/logical/FindAll.js
var import_react46 = __toESM(require_react());
var FindAll = import_react46.default.forwardRef((props, ref) => {
  const parent = (0, import_react46.useContext)(ParentContext);
  const found = useMemoOnce_default(() => new Resolvable());
  (0, import_react46.useLayoutEffect)(() => {
    if (!parent || !props.name) {
      found.resolve([]);
      return;
    }
    if ("loadedResolvable" in parent) {
      const handle = parent.loadedResolvable.then(() => found.resolve(parent.findAll(props.name)));
      return () => {
        handle.cancel();
      };
    }
    found.resolve(parent.findAll(props.name));
  }, []);
  const changed = useDiffProps_default(props);
  found.then((f) => {
    for (const [key, value] of changed)
      for (const child of f)
        child[key] = value;
  });
  return null;
});
var FindAll_default = FindAll;

// node_modules/lingo3d-react/lib/components/logical/Setup.js
var import_react47 = __toESM(require_react());
var Setup = (props) => {
  (0, import_react47.useLayoutEffect)(() => {
    applySetup_default(props);
  }, [JSON.stringify(props)]);
  return null;
};
var Setup_default = Setup;

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    let byte = bytes[size] & 63;
    if (byte < 36) {
      id += byte.toString(36);
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte < 63) {
      id += "_";
    } else {
      id += "-";
    }
  }
  return id;
};

// node_modules/lingo3d-react/lib/hooks/useSpawn.js
var import_react48 = __toESM(require_react());
var useSpawn_default = (o) => {
  const bullets = useMemoOnce_default(() => /* @__PURE__ */ new Set());
  const [, render] = (0, import_react48.useState)({});
  const factory = (cb2) => [...bullets].map((id) => cb2(id));
  const spawn = (_o) => {
    var _a;
    const options = __spreadValues(__spreadValues({}, o), _o);
    (_a = options.id) !== null && _a !== void 0 ? _a : options.id = nanoid();
    bullets.add(options);
    render({});
    options.lifetime && setTimeout(() => {
      bullets.delete(options);
      render({});
    }, options.lifetime);
  };
  return [factory, spawn];
};

// node_modules/tslib/tslib.es6.js
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/hey-listen/dist/hey-listen.es.js
var warning = function() {
};
var invariant = function() {
};
if (true) {
  warning = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/popmotion/dist/es/utils/clamp.mjs
var clamp = (min, max, v) => Math.min(Math.max(v, min), max);

// node_modules/popmotion/dist/es/animations/utils/find-spring.mjs
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - a / b * c;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/popmotion/dist/es/animations/generators/spring.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a) {
  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      };
      resolveVelocity = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t) => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from, to] = [to, from];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a, b) => typeof a === "string" || typeof b === "string";
var zero = (_t) => 0;

// node_modules/popmotion/dist/es/utils/progress.mjs
var progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};

// node_modules/popmotion/dist/es/utils/mix.mjs
var mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;

// node_modules/style-value-types/dist/es/utils.mjs
var clamp2 = (min, max) => (v) => Math.max(Math.min(v, max), min);
var sanitize = (v) => v % 1 ? Number(v.toFixed(5)) : v;
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString(v) {
  return typeof v === "string";
}

// node_modules/style-value-types/dist/es/numbers/index.mjs
var number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
var alpha = Object.assign(Object.assign({}, number), { transform: clamp2(0, 1) });
var scale = Object.assign(Object.assign({}, number), { default: 1 });

// node_modules/style-value-types/dist/es/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v) => isString(v) && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });

// node_modules/style-value-types/dist/es/color/utils.mjs
var isColorString = (type, testProp) => (v) => {
  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
};
var splitColor = (aName, bName, cName) => (v) => {
  if (!isString(v))
    return v;
  const [a, b, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/style-value-types/dist/es/color/hsla.mjs
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// node_modules/style-value-types/dist/es/color/rgba.mjs
var clampRgbUnit = clamp2(0, 255);
var rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });
var rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/style-value-types/dist/es/color/hex.mjs
function parseHex(v) {
  let r = "";
  let g = "";
  let b = "";
  let a = "";
  if (v.length > 5) {
    r = v.substr(1, 2);
    g = v.substr(3, 2);
    b = v.substr(5, 2);
    a = v.substr(7, 2);
  } else {
    r = v.substr(1, 1);
    g = v.substr(2, 1);
    b = v.substr(3, 1);
    a = v.substr(4, 1);
    r += r;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// node_modules/style-value-types/dist/es/color/index.mjs
var color = {
  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
  parse: (v) => {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return isString(v) ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
  }
};

// node_modules/style-value-types/dist/es/complex/index.mjs
var colorToken = "${c}";
var numberToken = "${n}";
function test(v) {
  var _a, _b, _c, _d;
  return isNaN(v) && isString(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse(v) {
  if (typeof v === "number")
    v = `${v}`;
  const values = [];
  let numColors = 0;
  const colors = v.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v = v.replace(colorRegex, colorToken);
    values.push(...colors.map(color.parse));
  }
  const numbers = v.match(floatRegex);
  if (numbers) {
    v = v.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v };
}
function parse(v) {
  return analyse(v).values;
}
function createTransformer(v) {
  const { values, numColors, tokenised } = analyse(v);
  const numValues = values.length;
  return (v2) => {
    let output = tokenised;
    for (let i = 0; i < numValues; i++) {
      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v2[i]) : sanitize(v2[i]));
    }
    return output;
  };
}
var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
function getAnimatableNone(v) {
  const parsed = parse(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = { test, parse, createTransformer, getAnimatableNone };

// node_modules/style-value-types/dist/es/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  let [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {
  const functions = v.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v;
} });

// node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}

// node_modules/popmotion/dist/es/utils/mix-color.mjs
var mixLinearColor = (from, to, v) => {
  const fromExpo = from * from;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = (v) => colorTypes.find((type) => type.test(v));
var notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;
var mixColor = (from, to) => {
  let fromColorType = getColorType(from);
  let toColorType = getColorType(to);
  invariant(!!fromColorType, notAnimatable(from));
  invariant(!!toColorType, notAnimatable(to));
  let fromColor = fromColorType.parse(from);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);
    return fromColorType.transform(blended);
  };
};

// node_modules/popmotion/dist/es/utils/inc.mjs
var isNum = (v) => typeof v === "number";

// node_modules/popmotion/dist/es/utils/pipe.mjs
var combineFunctions = (a, b) => (v) => b(a(v));
var pipe = (...transformers) => transformers.reduce(combineFunctions);

// node_modules/popmotion/dist/es/utils/mix-complex.mjs
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v) => mix(origin, target, v);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
var mixArray = (from, to) => {
  const output = [...from];
  const numValues = output.length;
  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }
    return output;
  };
};
var mixObject = (origin, target) => {
  const output = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
};
function analyse2(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse2(origin);
  const targetStats = analyse2(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return (p) => `${p > 0 ? target : origin}`;
  }
};

// node_modules/popmotion/dist/es/utils/interpolate.mjs
var mixNumber = (from, to) => (p) => mix(from, to, p);
function detectMixerFactory(v) {
  if (typeof v === "number") {
    return mixNumber;
  } else if (typeof v === "string") {
    if (color.test(v)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v)) {
    return mixArray;
  } else if (typeof v === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from, to], [mixer]) {
  return (v) => mixer(progress(from, to, v));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v <= input[0]) {
      foundMixerIndex = true;
    } else if (v >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i = 1;
      for (; i < inputLength; i++) {
        if (input[i] > v || i === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}

// node_modules/popmotion/dist/es/easing/utils.mjs
var reverseEasing = (easing) => (p) => 1 - easing(1 - p);
var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
var createExpoIn = (power) => (p) => Math.pow(p, power);
var createBackIn = (power) => (p) => p * p * ((power + 1) * p - power);
var createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p) => (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
};

// node_modules/popmotion/dist/es/easing/index.mjs
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = (p) => 1 - Math.sin(Math.acos(p));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = (p) => {
  if (p === 1 || p === 0)
    return p;
  const p2 = p * p;
  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;
};
var bounceIn = reverseEasing(bounceOut);

// node_modules/popmotion/dist/es/animations/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o) => o * duration);
}
function keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {
  const state = { done: false, value: from };
  const values = Array.isArray(to) ? to : [from, to];
  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t) => {
      state.value = interpolator(t);
      state.done = t >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}

// node_modules/popmotion/dist/es/animations/generators/decay.mjs
function decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from };
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from;
  return {
    next: (t) => {
      const delta = -amplitude * Math.exp(-t / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}

// node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs
var types = { keyframes, spring, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  const keys = new Set(Object.keys(config));
  if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
    return keyframes;
  } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
    return spring;
  }
  return keyframes;
}

// node_modules/framesync/dist/es/on-next-frame.mjs
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

// node_modules/framesync/dist/es/create-render-step.mjs
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index = toRunNextFrame.indexOf(callback);
      if (index !== -1)
        toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}

// node_modules/framesync/dist/es/index.mjs
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
var sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
var processStep = (stepId) => steps[stepId].process(frame);
var processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var es_default = sync;

// node_modules/popmotion/dist/es/animations/utils/elapsed.mjs
function loopElapsed(elapsed, duration, delay = 0) {
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}

// node_modules/popmotion/dist/es/animations/index.mjs
var framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => es_default.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate(_a) {
  var _b, _c;
  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = interpolate([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}

// node_modules/popmotion/dist/es/utils/attract.mjs
var identity = (v) => v;
var createAttractor = (alterDisplacement = identity) => (constant, origin, v) => {
  const displacement = origin - v;
  const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
  return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
};
var attract = createAttractor();
var attractExpo = createAttractor(Math.sqrt);

// node_modules/popmotion/dist/es/easing/cubic-bezier.mjs
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);

// node_modules/lingo3d-react/lib/hooks/useSpring.js
var import_react50 = __toESM(require_react());

// node_modules/lingo3d-react/lib/hooks/useValue.js
var import_react49 = __toESM(require_react());
var useValue_default = (o) => {
  const [setValue, getValue] = useMemoOnce_default(() => {
    var _a, _b, _c;
    const value = typeof (o === null || o === void 0 ? void 0 : o.from) === "function" ? o.from() : (_a = o === null || o === void 0 ? void 0 : o.from) !== null && _a !== void 0 ? _a : 0;
    return store((_c = (_b = o === null || o === void 0 ? void 0 : o.map) === null || _b === void 0 ? void 0 : _b.call(o, value)) !== null && _c !== void 0 ? _c : value);
  });
  (0, import_react49.useLayoutEffect)(() => {
    if (typeof (o === null || o === void 0 ? void 0 : o.from) !== "function")
      return;
    const { map } = o;
    if (map) {
      const handle2 = o.from((v) => setValue(map(v)));
      return () => {
        handle2.cancel();
      };
    }
    const handle = o.from(setValue);
    return () => {
      handle.cancel();
    };
  }, []);
  (0, import_react49.useLayoutEffect)(() => {
    const step = o === null || o === void 0 ? void 0 : o.step;
    if (!step)
      return;
    const handle = getValue(step);
    return () => {
      handle.cancel();
    };
  }, []);
  return [getValue, setValue];
};

// node_modules/lingo3d-react/lib/hooks/useSpring.js
var useSpring_default = (o) => {
  const _a = typeof o === "number" ? { to: o } : o, { to, from = to, step, delay } = _a, options = __objRest(_a, ["to", "from", "step", "delay"]);
  const [getValue, setValue] = useValue_default({ from, step });
  (0, import_react50.useLayoutEffect)(() => {
    const handle = new Cancellable();
    (async () => {
      await new Promise((resolve) => setTimeout(resolve, delay));
      if (handle.done)
        return;
      const anim = spring(__spreadValues({ from: getValue(), to }, options));
      const time = Date.now();
      handle.watch(loop(() => {
        const { value, done } = anim.next(Date.now() - time);
        setValue(value);
        if (done) {
          handle.cancel();
          return;
        }
      }));
    })();
    return () => {
      handle.cancel();
    };
  }, [to]);
  return getValue;
};

// node_modules/lingo3d-react/lib/hooks/useAnimation.js
var import_react51 = __toESM(require_react());
var useAnimation_default = (_a) => {
  var _b = _a, { from, to, duration = 1e3, stopped, step } = _b, options = __objRest(_b, ["from", "to", "duration", "stopped", "step"]);
  const [getValue, setValue] = useValue_default({ from, step });
  (0, import_react51.useLayoutEffect)(() => {
    if (stopped)
      return;
    const anim = animate(__spreadProps(__spreadValues({ from: getValue(), to, duration }, options), { onUpdate: setValue }));
    return () => {
      anim.stop();
    };
  }, [to, stopped]);
  return getValue;
};

// node_modules/lingo3d-react/lib/hooks/useLoop.js
var import_react52 = __toESM(require_react());
var useLoop_default = (cb2, play = true) => {
  const cbCurrentRef = useCurrentRef_default(cb2);
  (0, import_react52.useLayoutEffect)(() => {
    if (!play)
      return;
    const handle = loop(() => cbCurrentRef.current());
    return () => {
      handle.cancel();
    };
  }, [play]);
};

// node_modules/lingo3d-react/lib/hooks/useMouse.js
var import_react53 = __toESM(require_react());
var useMouse_default = () => {
  const statusRef = (0, import_react53.useRef)({ x: 0, y: 0, isDown: false });
  const [, render] = (0, import_react53.useState)({});
  (0, import_react53.useLayoutEffect)(() => {
    const mouse = new Mouse();
    mouse.onMouseMove = () => {
      statusRef.current.x = mouse.x;
      statusRef.current.y = mouse.y;
      render({});
    };
    mouse.onMouseDown = () => {
      statusRef.current.isDown = true;
      render({});
    };
    mouse.onMouseUp = () => {
      statusRef.current.isDown = false;
      render({});
    };
    return () => {
      mouse.dispose();
    };
  }, []);
  return statusRef.current;
};

// node_modules/lingo3d-react/lib/hooks/useKeyboard.js
var import_react54 = __toESM(require_react());
var useKeyboard_default = (cb2) => {
  const statusRef = (0, import_react54.useRef)();
  const [, render] = (0, import_react54.useState)({});
  const cbCurrentRef = useCurrentRef_default(cb2);
  (0, import_react54.useLayoutEffect)(() => {
    const keyboard = new Keyboard();
    keyboard.onKeyDown = (k) => {
      if (statusRef.current === k)
        return;
      statusRef.current = k;
      render({});
    };
    keyboard.onKeyUp = () => {
      statusRef.current = void 0;
      render({});
    };
    keyboard.onKeyPress = (k) => {
      var _a;
      return (_a = cbCurrentRef.current) === null || _a === void 0 ? void 0 : _a.call(cbCurrentRef, k);
    };
    return () => {
      keyboard.dispose();
    };
  }, []);
  return statusRef.current;
};

// node_modules/@lincode/react-reticle/lib/index.js
var import_react55 = __toESM(require_react());
import css from "/Users/hubert/Desktop/projects/animal-crossing/node_modules/@lincode/react-reticle/assets/style.module.css";
var Reticle = (_a) => {
  var _b = _a, { className } = _b, props = __objRest(_b, ["className"]);
  return import_react55.default.createElement("div", __spreadProps(__spreadValues({}, props), { className: css.center + " " + (className !== null && className !== void 0 ? className : "") }), import_react55.default.createElement("div", { style: {
    backgroundColor: "#999999",
    width: 20,
    height: 20,
    borderRadius: 9999,
    border: "1px solid white"
  } }));
};
var lib_default2 = Reticle;

// node_modules/@lincode/react-joystick/lib/index.js
var import_react56 = __toESM(require_react());
var import_react_device_detect = __toESM(require_lib());
var diameter = 100;
var radius = diameter / 2;
var useDrag = (cb2) => {
  const [el, setEl] = (0, import_react56.useState)(null);
  (0, import_react56.useEffect)(() => {
    if (!el)
      return;
    let down = false;
    const getCenter = () => {
      const { left, right, top, bottom } = el.getBoundingClientRect();
      return { x: (left + right) / 2, y: (top + bottom) / 2 };
    };
    const onMouseDown = (e) => {
      down = true;
      const { x, y } = getCenter();
      cb2({ deltaX: e.clientX - x, deltaY: e.clientY - y });
    };
    const onTouchStart = (e) => {
      e.stopPropagation();
      e.preventDefault();
      down = true;
      const { x, y } = getCenter();
      cb2({ deltaX: e.targetTouches[0].clientX - x, deltaY: e.targetTouches[0].clientY - y });
    };
    const onMouseMove = (e) => {
      if (!down)
        return;
      const { x, y } = getCenter();
      cb2({ deltaX: e.clientX - x, deltaY: e.clientY - y });
    };
    const onTouchMove = (e) => {
      e.stopPropagation();
      if (!down)
        return;
      const { x, y } = getCenter();
      cb2({ deltaX: e.targetTouches[0].clientX - x, deltaY: e.targetTouches[0].clientY - y });
    };
    const onMouseUp = () => {
      down = false;
      cb2({ deltaX: 0, deltaY: 0 });
    };
    const onTouchEnd = (e) => {
      e.stopPropagation();
      down = false;
      cb2({ deltaX: 0, deltaY: 0 });
    };
    if (import_react_device_detect.isMobile) {
      el.addEventListener("touchstart", onTouchStart);
      el.addEventListener("touchmove", onTouchMove);
      el.addEventListener("touchend", onTouchEnd);
    } else {
      el.addEventListener("mousedown", onMouseDown);
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    return () => {
      if (import_react_device_detect.isMobile) {
        el.removeEventListener("touchstart", onTouchStart);
        el.removeEventListener("touchmove", onTouchMove);
        el.removeEventListener("touchend", onTouchEnd);
      } else {
        el.removeEventListener("mousedown", onMouseDown);
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
    };
  }, [el]);
  return setEl;
};
var circleElement = import_react56.default.createElement("div", { style: {
  width: "100%",
  height: "100%",
  borderRadius: 9999,
  backgroundColor: "currentColor",
  border: "1px solid white",
  opacity: 0.25
} });
var Joystick = (_a) => {
  var _b = _a, { onMove, onMoveStart, onMoveEnd, position = "bottom-left", style, outerElement, innerElement } = _b, restProps = __objRest(_b, ["onMove", "onMoveStart", "onMoveEnd", "position", "style", "outerElement", "innerElement"]);
  const [delta, setDelta] = (0, import_react56.useState)([0, 0, 0]);
  const deltaRef = useCurrentRef_default(delta);
  const isMoved = delta[0] !== 0 || delta[1] !== 0;
  const isMovedTruthy = useTruthy_default(isMoved);
  (0, import_react56.useLayoutEffect)(() => {
    if (!isMovedTruthy)
      return;
    if (isMoved)
      onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart();
    else
      onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd();
    if (!isMoved)
      return;
    let anim;
    const loop2 = () => anim = requestAnimationFrame(() => {
      loop2();
      const [x, y, angle2] = deltaRef.current;
      onMove === null || onMove === void 0 ? void 0 : onMove({ x, y, angle: angle2 });
    });
    loop2();
    return () => {
      cancelAnimationFrame(anim);
    };
  }, [isMoved, isMovedTruthy]);
  const setDragEl = useDrag(({ deltaX, deltaY }) => {
    const angle2 = Math.atan2(deltaY, deltaX) * rad2Deg;
    const dist = Math.min(distance(0, 0, deltaX, deltaY), radius);
    const { x, y } = endPoint(0, 0, angle2, dist);
    setDelta([x, y, angle2]);
  });
  const [ly, lx] = position.split("-");
  return import_react56.default.createElement("div", __spreadProps(__spreadValues({}, restProps), { ref: setDragEl, style: __spreadValues({
    width: diameter,
    height: diameter,
    color: "#999999",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    position: "absolute",
    left: lx === "left" ? "0px" : void 0,
    right: lx === "right" ? "0px" : void 0,
    top: ly === "top" ? "0px" : void 0,
    bottom: ly === "bottom" ? "0px" : void 0,
    margin: "5%"
  }, style) }), import_react56.default.createElement("div", { style: { position: "absolute", width: "100%", height: "100%" } }, outerElement !== null && outerElement !== void 0 ? outerElement : circleElement), import_react56.default.createElement("div", { style: { width: radius, height: radius, transform: `translate(${delta[0]}px, ${delta[1]}px)` } }, innerElement !== null && innerElement !== void 0 ? innerElement : circleElement));
};
var lib_default3 = Joystick;
export {
  AmbientLight_default2 as AmbientLight,
  AreaLight_default2 as AreaLight,
  Camera_default as Camera,
  Circle_default as Circle,
  Cone_default as Cone,
  Cube_default as Cube,
  Cylinder_default as Cylinder,
  DirectionalLight_default2 as DirectionalLight,
  FindAll_default as FindAll,
  Group_default as Group,
  lib_default3 as Joystick,
  Keyboard_default as Keyboard,
  Model_default as Model,
  Mouse_default as Mouse,
  Octahedron_default as Octahedron,
  OrbitCamera_default2 as OrbitCamera,
  Plane_default as Plane,
  PointLight_default2 as PointLight,
  Reflector_default as Reflector,
  lib_default2 as Reticle,
  Scene_default as Scene,
  Setup_default as Setup,
  SkyLight_default2 as SkyLight,
  Skybox_default as Skybox,
  Sphere_default as Sphere,
  SpotLight_default2 as SpotLight,
  Sprite_default2 as Sprite,
  SvgMesh_default2 as SvgMesh,
  Tetrahedron_default as Tetrahedron,
  ThirdPersonCamera_default as ThirdPersonCamera,
  Torus_default as Torus,
  World_default as World,
  useAnimation_default as useAnimation,
  useKeyboard_default as useKeyboard,
  useLoop_default as useLoop,
  useMouse_default as useMouse,
  useSpawn_default as useSpawn,
  useSpring_default as useSpring,
  useValue_default as useValue
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=lingo3d-react.js.map

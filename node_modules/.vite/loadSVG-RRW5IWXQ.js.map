{
  "version": 3,
  "sources": ["../three/examples/jsm/loaders/SVGLoader.js", "../lingo3d/lib/display/utils/loaders/loadSVG.js"],
  "sourcesContent": ["import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass SVGLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet traverseChildNodes = true;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tconst nodes = node.childNodes;\n\n\t\t\t\tfor ( let i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\t// Remove empty rules\n\t\t\t\t\tconst definitions = Object.fromEntries(\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\n\t\t\t\t\t);\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tdefinitions\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute \u03B81 and \u0394\u03B8\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tconst isRotated = isTransformRotated( m );\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet identifier = 0;\n\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape();\n\t\t\t\tshape.curves = p.curves;\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\n\t\t\t\t\tconst path = new Path();\n\t\t\t\t\tpath.curves = hole.curves;\n\t\t\t\t\tshape.holes.push( path );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n", "import { SVGLoader } from \"three/examples/jsm/loaders/SVGLoader\";\nimport { forceGet } from \"@lincode/utils\";\nimport { increaseLoadingCount, decreaseLoadingCount } from \"../../../states/useLoadingCount\";\nconst cache = new Map();\nconst loader = new SVGLoader();\nexport default (url) => forceGet(cache, url, () => new Promise((resolve, reject) => {\n    increaseLoadingCount();\n    loader.load(url, svg => {\n        decreaseLoadingCount();\n        resolve(Object.freeze(svg));\n    }, undefined, () => {\n        decreaseLoadingCount();\n        reject();\n    });\n}));\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AAeA,8BAAwB,OAAO;AAAA,EAE9B,YAAa,SAAU;AAEtB,UAAO,OAAQ;AAGf,SAAK,aAAa;AAGlB,SAAK,cAAc;AAAA,EAEpB;AAAA,EAEA,KAAM,KAAK,QAAQ,YAAY,SAAU;AAExC,UAAM,QAAQ;AAEd,UAAM,UAAS,IAAI,WAAY,MAAM,OAAQ;AAC7C,YAAO,QAAS,MAAM,IAAK;AAC3B,YAAO,iBAAkB,MAAM,aAAc;AAC7C,YAAO,mBAAoB,MAAM,eAAgB;AACjD,YAAO,KAAM,KAAK,SAAW,MAAO;AAEnC,UAAI;AAEH,eAAQ,MAAM,MAAO,IAAK,CAAE;AAAA,MAE7B,SAAU,GAAR;AAED,YAAK,SAAU;AAEd,kBAAS,CAAE;AAAA,QAEZ,OAAO;AAEN,kBAAQ,MAAO,CAAE;AAAA,QAElB;AAEA,cAAM,QAAQ,UAAW,GAAI;AAAA,MAE9B;AAAA,IAED,GAAG,YAAY,OAAQ;AAAA,EAExB;AAAA,EAEA,MAAO,MAAO;AAEb,UAAM,QAAQ;AAEd,uBAAoB,MAAM,OAAQ;AAEjC,UAAK,KAAK,aAAa;AAAI;AAE3B,YAAM,YAAY,iBAAkB,IAAK;AAEzC,UAAI,qBAAqB;AAEzB,UAAI,OAAO;AAEX,cAAS,KAAK;AAAA,aAER;AACJ;AAAA,aAEI;AACJ,6BAAoB,IAAK;AACzB;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC,cAAK,KAAK,aAAc,GAAI;AAAI,mBAAO,cAAe,IAAK;AAC3D;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC,iBAAO,cAAe,IAAK;AAC3B;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC,iBAAO,iBAAkB,IAAK;AAC9B;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC,iBAAO,kBAAmB,IAAK;AAC/B;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC,iBAAO,gBAAiB,IAAK;AAC7B;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC,iBAAO,iBAAkB,IAAK;AAC9B;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAChC,iBAAO,cAAe,IAAK;AAC3B;AAAA,aAEI;AACJ,+BAAqB;AACrB;AAAA,aAEI;AACJ,kBAAQ,WAAY,MAAM,KAAM;AAEhC,gBAAM,OAAO,KAAK,eAAgB,gCAAgC,MAAO,KAAK;AAC9E,gBAAM,aAAa,KAAK,UAAW,CAAE;AACrC,gBAAM,WAAW,KAAK,gBAAgB,eAAgB,UAAW;AACjE,cAAK,UAAW;AAEf,sBAAW,UAAU,KAAM;AAAA,UAE5B,OAAO;AAEN,oBAAQ,KAAM,4DAA8D,UAAW;AAAA,UAExF;AAEA;AAAA;AAAA;AAOF,UAAK,MAAO;AAEX,YAAK,MAAM,SAAS,UAAa,MAAM,SAAS,QAAS;AAExD,eAAK,MAAM,SAAU,MAAM,IAAK;AAAA,QAEjC;AAEA,sBAAe,MAAM,gBAAiB;AAEtC,cAAM,KAAM,IAAK;AAEjB,aAAK,WAAW,EAAE,MAAY,MAAa;AAAA,MAE5C;AAEA,UAAK,oBAAqB;AAEzB,cAAM,QAAQ,KAAK;AAEnB,iBAAU,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAO;AAEzC,oBAAW,MAAO,IAAK,KAAM;AAAA,QAE9B;AAAA,MAED;AAEA,UAAK,WAAY;AAEhB,uBAAe,IAAI;AAEnB,YAAK,eAAe,SAAS,GAAI;AAEhC,2BAAiB,KAAM,eAAgB,eAAe,SAAS,EAAI;AAAA,QAEpE,OAAO;AAEN,2BAAiB,SAAS;AAAA,QAE3B;AAAA,MAED;AAAA,IAED;AAEA,2BAAwB,MAAO;AAE9B,YAAM,OAAO,IAAI,UAAU;AAE3B,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,UAAU,IAAI,QAAQ;AAE5B,YAAM,aAAa,IAAI,QAAQ;AAC/B,UAAI,eAAe;AACnB,UAAI,kBAAkB;AAEtB,YAAM,IAAI,KAAK,aAAc,GAAI;AAIjC,YAAM,WAAW,EAAE,MAAO,sBAAuB;AAEjD,eAAU,IAAI,GAAG,IAAI,SAAS,QAAQ,IAAI,GAAG,KAAO;AAEnD,cAAM,UAAU,SAAU;AAE1B,cAAM,OAAO,QAAQ,OAAQ,CAAE;AAC/B,cAAM,QAAO,QAAQ,OAAQ,CAAE,EAAE,KAAK;AAEtC,YAAK,iBAAiB,MAAO;AAE5B,4BAAkB;AAClB,yBAAe;AAAA,QAEhB;AAEA,YAAI;AAEJ,gBAAS;AAAA,eAEH;AACJ,sBAAU,YAAa,KAAK;AAC5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,oBAAM,IAAI,QAAS,IAAI;AACvB,oBAAM,IAAI,QAAS,IAAI;AACvB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAElB,kBAAK,MAAM,GAAI;AAEd,qBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAAA,cAE/B,OAAO;AAEN,qBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAAA,cAE/B;AAEA,kBAAK,MAAM;AAAI,2BAAW,KAAM,KAAM;AAAA,YAEvC;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAO;AAEpD,oBAAM,IAAI,QAAS;AACnB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,mBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAE9B,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAO;AAEpD,oBAAM,IAAI,QAAS;AACnB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,mBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAE9B,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,oBAAM,IAAI,QAAS,IAAI;AACvB,oBAAM,IAAI,QAAS,IAAI;AACvB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,mBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAE9B,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,mBAAK,cACJ,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,EACd;AACA,sBAAQ,IAAI,QAAS,IAAI;AACzB,sBAAQ,IAAI,QAAS,IAAI;AACzB,oBAAM,IAAI,QAAS,IAAI;AACvB,oBAAM,IAAI,QAAS,IAAI;AAEvB,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,mBAAK,cACJ,cAAe,MAAM,GAAG,QAAQ,CAAE,GAClC,cAAe,MAAM,GAAG,QAAQ,CAAE,GAClC,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,EACd;AACA,sBAAQ,IAAI,QAAS,IAAI;AACzB,sBAAQ,IAAI,QAAS,IAAI;AACzB,oBAAM,IAAI,QAAS,IAAI;AACvB,oBAAM,IAAI,QAAS,IAAI;AAEvB,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,mBAAK,iBACJ,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,IACb,QAAS,IAAI,EACd;AACA,sBAAQ,IAAI,QAAS,IAAI;AACzB,sBAAQ,IAAI,QAAS,IAAI;AACzB,oBAAM,IAAI,QAAS,IAAI;AACvB,oBAAM,IAAI,QAAS,IAAI;AAEvB,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,oBAAM,KAAK,cAAe,MAAM,GAAG,QAAQ,CAAE;AAC7C,oBAAM,KAAK,cAAe,MAAM,GAAG,QAAQ,CAAE;AAC7C,mBAAK,iBACJ,IACA,IACA,QAAS,IAAI,IACb,QAAS,IAAI,EACd;AACA,sBAAQ,IAAI;AACZ,sBAAQ,IAAI;AACZ,oBAAM,IAAI,QAAS,IAAI;AACvB,oBAAM,IAAI,QAAS,IAAI;AAEvB,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,OAAM,CAAE,GAAG,CAAE,GAAG,CAAE;AAEzC,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAGtD,kBAAK,QAAS,IAAI,MAAO,MAAM,KAAK,QAAS,IAAI,MAAO,MAAM;AAAI;AAElE,oBAAM,QAAQ,MAAM,MAAM;AAC1B,oBAAM,IAAI,QAAS,IAAI;AACvB,oBAAM,IAAI,QAAS,IAAI;AACvB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,8BACC,MAAM,QAAS,IAAK,QAAS,IAAI,IAAK,QAAS,IAAI,IAAK,QAAS,IAAI,IAAK,QAAS,IAAI,IAAK,OAAO,KACpG;AAEA,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,oBAAM,KAAK,QAAS,IAAI;AACxB,oBAAM,KAAK,QAAS,IAAI;AACxB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAElB,kBAAK,MAAM,GAAI;AAEd,qBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAAA,cAE/B,OAAO;AAEN,qBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAAA,cAE/B;AAEA,kBAAK,MAAM;AAAI,2BAAW,KAAM,KAAM;AAAA,YAEvC;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAO;AAEpD,oBAAM,KAAK,QAAS;AACpB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,mBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAE9B,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAO;AAEpD,oBAAM,KAAK,QAAS;AACpB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,mBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAE9B,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,oBAAM,KAAK,QAAS,IAAI;AACxB,oBAAM,KAAK,QAAS,IAAI;AACxB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,mBAAK,OAAQ,MAAM,GAAG,MAAM,CAAE;AAE9B,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,mBAAK,cACJ,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,EACxB;AACA,sBAAQ,IAAI,MAAM,IAAI,QAAS,IAAI;AACnC,sBAAQ,IAAI,MAAM,IAAI,QAAS,IAAI;AACnC,oBAAM,KAAK,QAAS,IAAI;AACxB,oBAAM,KAAK,QAAS,IAAI;AAExB,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,mBAAK,cACJ,cAAe,MAAM,GAAG,QAAQ,CAAE,GAClC,cAAe,MAAM,GAAG,QAAQ,CAAE,GAClC,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,EACxB;AACA,sBAAQ,IAAI,MAAM,IAAI,QAAS,IAAI;AACnC,sBAAQ,IAAI,MAAM,IAAI,QAAS,IAAI;AACnC,oBAAM,KAAK,QAAS,IAAI;AACxB,oBAAM,KAAK,QAAS,IAAI;AAExB,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,mBAAK,iBACJ,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,EACxB;AACA,sBAAQ,IAAI,MAAM,IAAI,QAAS,IAAI;AACnC,sBAAQ,IAAI,MAAM,IAAI,QAAS,IAAI;AACnC,oBAAM,KAAK,QAAS,IAAI;AACxB,oBAAM,KAAK,QAAS,IAAI;AAExB,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,KAAK;AAE5B,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAEtD,oBAAM,KAAK,cAAe,MAAM,GAAG,QAAQ,CAAE;AAC7C,oBAAM,KAAK,cAAe,MAAM,GAAG,QAAQ,CAAE;AAC7C,mBAAK,iBACJ,IACA,IACA,MAAM,IAAI,QAAS,IAAI,IACvB,MAAM,IAAI,QAAS,IAAI,EACxB;AACA,sBAAQ,IAAI;AACZ,sBAAQ,IAAI;AACZ,oBAAM,IAAI,MAAM,IAAI,QAAS,IAAI;AACjC,oBAAM,IAAI,MAAM,IAAI,QAAS,IAAI;AAEjC,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AACJ,sBAAU,YAAa,OAAM,CAAE,GAAG,CAAE,GAAG,CAAE;AAEzC,qBAAU,IAAI,GAAG,KAAK,QAAQ,QAAQ,IAAI,IAAI,KAAK,GAAI;AAGtD,kBAAK,QAAS,IAAI,MAAO,KAAK,QAAS,IAAI,MAAO;AAAI;AAEtD,oBAAM,QAAQ,MAAM,MAAM;AAC1B,oBAAM,KAAK,QAAS,IAAI;AACxB,oBAAM,KAAK,QAAS,IAAI;AACxB,sBAAQ,IAAI,MAAM;AAClB,sBAAQ,IAAI,MAAM;AAClB,8BACC,MAAM,QAAS,IAAK,QAAS,IAAI,IAAK,QAAS,IAAI,IAAK,QAAS,IAAI,IAAK,QAAS,IAAI,IAAK,OAAO,KACpG;AAEA,kBAAK,MAAM,KAAK,oBAAoB;AAAO,2BAAW,KAAM,KAAM;AAAA,YAEnE;AAEA;AAAA,eAEI;AAAA,eACA;AACJ,iBAAK,YAAY,YAAY;AAE7B,gBAAK,KAAK,YAAY,OAAO,SAAS,GAAI;AAGzC,oBAAM,KAAM,UAAW;AACvB,mBAAK,YAAY,aAAa,KAAM,KAAM;AAC1C,6BAAe;AAAA,YAEhB;AAEA;AAAA;AAGA,oBAAQ,KAAM,OAAQ;AAAA;AAMxB,0BAAkB;AAAA,MAEnB;AAEA,aAAO;AAAA,IAER;AAEA,gCAA6B,MAAO;AAEnC,UAAK,CAAE,KAAK,SAAS,CAAE,KAAK,MAAM,YAAY,CAAE,KAAK,MAAM,SAAS;AAAS;AAE7E,eAAU,IAAI,GAAG,IAAI,KAAK,MAAM,SAAS,QAAQ,KAAO;AAEvD,cAAM,aAAa,KAAK,MAAM,SAAU;AAExC,YAAK,WAAW,SAAS;AAAI;AAE7B,cAAM,eAAe,WAAW,aAC9B,MAAO,KAAM,EACb,OAAQ,OAAQ,EAChB,IAAK,QAAK,GAAE,KAAK,CAAE;AAErB,iBAAU,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAO;AAGhD,gBAAM,cAAc,OAAO,YAC1B,OAAO,QAAS,WAAW,KAAM,EAAE,OAAQ,CAAE,CAAE,EAAE,OAAS,MAAM,EAAG,CACpE;AAEA,sBAAa,aAAc,MAAQ,OAAO,OACzC,YAAa,aAAc,OAAS,CAAC,GACrC,WACD;AAAA,QAED;AAAA,MAED;AAAA,IAED;AAWA,6BAA0B,MAAM,IAAI,IAAI,iBAAiB,gBAAgB,YAAY,OAAO,KAAM;AAEjG,UAAK,MAAM,KAAK,MAAM,GAAI;AAGzB,aAAK,OAAQ,IAAI,GAAG,IAAI,CAAE;AAC1B;AAAA,MAED;AAEA,wBAAkB,kBAAkB,KAAK,KAAK;AAG9C,WAAK,KAAK,IAAK,EAAG;AAClB,WAAK,KAAK,IAAK,EAAG;AAGlB,YAAM,MAAQ,OAAM,IAAI,IAAI,KAAM;AAClC,YAAM,MAAQ,OAAM,IAAI,IAAI,KAAM;AAClC,YAAM,MAAM,KAAK,IAAK,eAAgB,IAAI,MAAM,KAAK,IAAK,eAAgB,IAAI;AAC9E,YAAM,MAAM,CAAE,KAAK,IAAK,eAAgB,IAAI,MAAM,KAAK,IAAK,eAAgB,IAAI;AAGhF,UAAI,MAAM,KAAK;AACf,UAAI,MAAM,KAAK;AACf,YAAM,OAAO,MAAM;AACnB,YAAM,OAAO,MAAM;AAGnB,YAAM,KAAK,OAAO,MAAM,OAAO;AAE/B,UAAK,KAAK,GAAI;AAGb,cAAM,IAAI,KAAK,KAAM,EAAG;AACxB,aAAK,IAAI;AACT,aAAK,IAAI;AACT,cAAM,KAAK;AACX,cAAM,KAAK;AAAA,MAEZ;AAEA,YAAM,KAAO,MAAM,OAAO,MAAM;AAChC,YAAM,KAAO,OAAM,MAAM,MAAO;AAChC,UAAI,IAAI,KAAK,KAAM,KAAK,IAAK,GAAG,EAAG,CAAE;AACrC,UAAK,mBAAmB;AAAa,YAAI,CAAE;AAC3C,YAAM,MAAM,IAAI,KAAK,MAAM;AAC3B,YAAM,MAAM,CAAE,IAAI,KAAK,MAAM;AAG7B,YAAM,KAAK,KAAK,IAAK,eAAgB,IAAI,MAAM,KAAK,IAAK,eAAgB,IAAI,MAAQ,OAAM,IAAI,IAAI,KAAM;AACzG,YAAM,KAAK,KAAK,IAAK,eAAgB,IAAI,MAAM,KAAK,IAAK,eAAgB,IAAI,MAAQ,OAAM,IAAI,IAAI,KAAM;AAGzG,YAAM,QAAQ,SAAU,GAAG,GAAK,OAAM,OAAQ,IAAM,OAAM,OAAQ,EAAG;AACrE,YAAM,QAAQ,SAAY,OAAM,OAAQ,IAAM,OAAM,OAAQ,IAAM,EAAE,MAAM,OAAQ,IAAM,EAAE,MAAM,OAAQ,EAAG,IAAM,MAAK,KAAK;AAE3H,WAAK,YAAY,WAAY,IAAI,IAAI,IAAI,IAAI,OAAO,QAAQ,OAAO,eAAe,GAAG,eAAgB;AAAA,IAEtG;AAEA,sBAAmB,IAAI,IAAI,IAAI,IAAK;AAEnC,YAAM,MAAM,KAAK,KAAK,KAAK;AAC3B,YAAM,MAAM,KAAK,KAAM,KAAK,KAAK,KAAK,EAAG,IAAI,KAAK,KAAM,KAAK,KAAK,KAAK,EAAG;AAC1E,UAAI,MAAM,KAAK,KAAM,KAAK,IAAK,IAAK,KAAK,IAAK,GAAG,MAAM,GAAI,CAAE,CAAE;AAC/D,UAAO,KAAK,KAAK,KAAK,KAAO;AAAI,cAAM,CAAE;AACzC,aAAO;AAAA,IAER;AAMA,2BAAwB,MAAO;AAE9B,YAAM,IAAI,oBAAqB,KAAK,aAAc,GAAI,KAAK,CAAE;AAC7D,YAAM,IAAI,oBAAqB,KAAK,aAAc,GAAI,KAAK,CAAE;AAC7D,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,KAAK,aAAc,IAAK,KAAK,CAAE;AAC5F,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,KAAK,aAAc,IAAK,KAAK,CAAE;AAC5F,YAAM,IAAI,oBAAqB,KAAK,aAAc,OAAQ,CAAE;AAC5D,YAAM,IAAI,oBAAqB,KAAK,aAAc,QAAS,CAAE;AAI7D,YAAM,MAAM,IAAI;AAEhB,YAAM,OAAO,IAAI,UAAU;AAG3B,WAAK,OAAQ,IAAI,IAAI,CAAE;AAGvB,WAAK,OAAQ,IAAI,IAAI,IAAI,CAAE;AAC3B,UAAK,OAAO,KAAK,OAAO,GAAI;AAE3B,aAAK,cACJ,IAAI,IAAI,KAAK,KACb,GACA,IAAI,GACJ,IAAI,KAAK,KACT,IAAI,GACJ,IAAI,EACL;AAAA,MAED;AAGA,WAAK,OAAQ,IAAI,GAAG,IAAI,IAAI,EAAG;AAC/B,UAAK,OAAO,KAAK,OAAO,GAAI;AAE3B,aAAK,cACJ,IAAI,GACJ,IAAI,IAAI,KAAK,KACb,IAAI,IAAI,KAAK,KACb,IAAI,GACJ,IAAI,IAAI,IACR,IAAI,CACL;AAAA,MAED;AAGA,WAAK,OAAQ,IAAI,IAAI,IAAI,CAAE;AAC3B,UAAK,OAAO,KAAK,OAAO,GAAI;AAE3B,aAAK,cACJ,IAAI,KAAK,KACT,IAAI,GACJ,GACA,IAAI,IAAI,KAAK,KACb,GACA,IAAI,IAAI,EACT;AAAA,MAED;AAGA,WAAK,OAAQ,GAAG,IAAI,EAAG;AACvB,UAAK,OAAO,KAAK,OAAO,GAAI;AAE3B,aAAK,cAAe,GAAG,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,GAAG,IAAI,IAAI,CAAE;AAAA,MAEjE;AAEA,aAAO;AAAA,IAER;AAEA,8BAA2B,MAAO;AAEjC,wBAAmB,OAAO,GAAG,GAAI;AAEhC,cAAM,IAAI,oBAAqB,CAAE;AACjC,cAAM,IAAI,oBAAqB,CAAE;AAEjC,YAAK,UAAU,GAAI;AAElB,eAAK,OAAQ,GAAG,CAAE;AAAA,QAEnB,OAAO;AAEN,eAAK,OAAQ,GAAG,CAAE;AAAA,QAEnB;AAEA;AAAA,MAED;AAEA,YAAM,QAAQ;AAEd,YAAM,OAAO,IAAI,UAAU;AAE3B,UAAI,QAAQ;AAEZ,WAAK,aAAc,QAAS,EAAE,QAAS,OAAO,QAAS;AAEvD,WAAK,YAAY,YAAY;AAE7B,aAAO;AAAA,IAER;AAEA,+BAA4B,MAAO;AAElC,wBAAmB,OAAO,GAAG,GAAI;AAEhC,cAAM,IAAI,oBAAqB,CAAE;AACjC,cAAM,IAAI,oBAAqB,CAAE;AAEjC,YAAK,UAAU,GAAI;AAElB,eAAK,OAAQ,GAAG,CAAE;AAAA,QAEnB,OAAO;AAEN,eAAK,OAAQ,GAAG,CAAE;AAAA,QAEnB;AAEA;AAAA,MAED;AAEA,YAAM,QAAQ;AAEd,YAAM,OAAO,IAAI,UAAU;AAE3B,UAAI,QAAQ;AAEZ,WAAK,aAAc,QAAS,EAAE,QAAS,OAAO,QAAS;AAEvD,WAAK,YAAY,YAAY;AAE7B,aAAO;AAAA,IAER;AAEA,6BAA0B,MAAO;AAEhC,YAAM,IAAI,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC9D,YAAM,IAAI,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC9D,YAAM,IAAI,oBAAqB,KAAK,aAAc,GAAI,KAAK,CAAE;AAE7D,YAAM,UAAU,IAAI,KAAK;AACzB,cAAQ,OAAQ,GAAG,GAAG,GAAG,GAAG,KAAK,KAAK,CAAE;AAExC,YAAM,OAAO,IAAI,UAAU;AAC3B,WAAK,SAAS,KAAM,OAAQ;AAE5B,aAAO;AAAA,IAER;AAEA,8BAA2B,MAAO;AAEjC,YAAM,IAAI,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC9D,YAAM,IAAI,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC9D,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC/D,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAE/D,YAAM,UAAU,IAAI,KAAK;AACzB,cAAQ,WAAY,GAAG,GAAG,IAAI,IAAI,GAAG,KAAK,KAAK,CAAE;AAEjD,YAAM,OAAO,IAAI,UAAU;AAC3B,WAAK,SAAS,KAAM,OAAQ;AAE5B,aAAO;AAAA,IAER;AAEA,2BAAwB,MAAO;AAE9B,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC/D,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC/D,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAC/D,YAAM,KAAK,oBAAqB,KAAK,aAAc,IAAK,KAAK,CAAE;AAE/D,YAAM,OAAO,IAAI,UAAU;AAC3B,WAAK,OAAQ,IAAI,EAAG;AACpB,WAAK,OAAQ,IAAI,EAAG;AACpB,WAAK,YAAY,YAAY;AAE7B,aAAO;AAAA,IAER;AAIA,wBAAqB,MAAM,OAAQ;AAElC,cAAQ,OAAO,OAAQ,CAAC,GAAG,KAAM;AAEjC,UAAI,mBAAmB,CAAC;AAExB,UAAK,KAAK,aAAc,OAAQ,GAAI;AAEnC,cAAM,iBAAiB,KAAK,aAAc,OAAQ,EAChD,MAAO,IAAK,EACZ,OAAQ,OAAQ,EAChB,IAAK,OAAK,EAAE,KAAK,CAAE;AAErB,iBAAU,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAO;AAElD,6BAAmB,OAAO,OAAQ,kBAAkB,YAAa,MAAM,eAAgB,GAAM;AAAA,QAE9F;AAAA,MAED;AAEA,UAAK,KAAK,aAAc,IAAK,GAAI;AAEhC,2BAAmB,OAAO,OAAQ,kBAAkB,YAAa,MAAM,KAAK,aAAc,IAAK,EAAI;AAAA,MAEpG;AAEA,wBAAmB,SAAS,QAAQ,gBAAiB;AAEpD,YAAK,mBAAmB;AAAY,2BAAiB,cAAe,GAAI;AAEvE,gBAAK,EAAE,WAAY,KAAM;AAAI,sBAAQ,KAAM,yDAA0D;AAErG,mBAAO;AAAA,UAER;AAEA,YAAK,KAAK,aAAc,OAAQ;AAAI,gBAAO,UAAW,eAAgB,KAAK,aAAc,OAAQ,CAAE;AACnG,YAAK,iBAAkB;AAAY,gBAAO,UAAW,eAAgB,iBAAkB,QAAU;AACjG,YAAK,KAAK,SAAS,KAAK,MAAO,aAAc;AAAK,gBAAO,UAAW,eAAgB,KAAK,MAAO,QAAU;AAAA,MAE3G;AAEA,qBAAgB,GAAI;AAEnB,eAAO,KAAK,IAAK,GAAG,KAAK,IAAK,GAAG,oBAAqB,CAAE,CAAE,CAAE;AAAA,MAE7D;AAEA,wBAAmB,GAAI;AAEtB,eAAO,KAAK,IAAK,GAAG,oBAAqB,CAAE,CAAE;AAAA,MAE9C;AAEA,eAAU,QAAQ,MAAO;AACzB,eAAU,gBAAgB,eAAe,KAAM;AAC/C,eAAU,aAAa,UAAW;AAClC,eAAU,WAAW,WAAW,KAAM;AACtC,eAAU,UAAU,QAAS;AAC7B,eAAU,kBAAkB,iBAAiB,KAAM;AACnD,eAAU,gBAAgB,eAAe,QAAS;AAClD,eAAU,mBAAmB,gBAAiB;AAC9C,eAAU,kBAAkB,eAAgB;AAC5C,eAAU,qBAAqB,oBAAoB,QAAS;AAC5D,eAAU,cAAc,YAAa;AAErC,aAAO;AAAA,IAER;AAIA,2BAAwB,GAAG,GAAI;AAE9B,aAAO,IAAM,KAAI;AAAA,IAElB;AAIA,yBAAsB,OAAO,OAAO,QAAS;AAE5C,UAAK,OAAO,UAAU,UAAW;AAEhC,cAAM,IAAI,UAAW,oBAAoB,OAAO,KAAM;AAAA,MAEvD;AAGA,YAAM,KAAK;AAAA,QACV,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,MAAM;AAAA,QACN,OAAO;AAAA,QACP,OAAO;AAAA,QACP,KAAK;AAAA,QACL,OAAO;AAAA,MACR;AAGA,YAAM,MAAM;AACZ,YAAM,MAAM;AACZ,YAAM,QAAQ;AACd,YAAM,MAAM;AAEZ,UAAI,QAAQ;AACZ,UAAI,YAAY;AAChB,UAAI,SAAS,IAAI,WAAW;AAC5B,YAAM,SAAS,CAAC;AAEhB,gCAA2B,UAAS,GAAG,SAAU;AAEhD,cAAM,QAAQ,IAAI,YAAa,2BAA2B,WAAU,gBAAgB,IAAI,GAAI;AAC5F,cAAM,UAAU;AAChB,cAAM;AAAA,MAEP;AAEA,2BAAqB;AAEpB,YAAK,WAAW,IAAK;AAEpB,cAAK,aAAa;AAAK,mBAAO,KAAM,OAAQ,MAAO,CAAE;AAAA;AAChD,mBAAO,KAAM,OAAQ,MAAO,IAAI,KAAK,IAAK,IAAI,OAAQ,QAAS,CAAE,CAAE;AAAA,QAEzE;AAEA,iBAAS;AACT,mBAAW;AAAA,MAEZ;AAEA,UAAI;AACJ,YAAM,SAAS,MAAM;AAErB,eAAU,IAAI,GAAG,IAAI,QAAQ,KAAO;AAEnC,kBAAU,MAAO;AAGjB,YAAK,MAAM,QAAS,KAAM,KAAK,MAAM,SAAU,OAAO,SAAS,MAAO,KAAK,GAAG,MAAM,KAAM,OAAQ,GAAI;AAErG,kBAAQ;AACR,mBAAS;AACT,oBAAU;AACV;AAAA,QAED;AAGA,YAAK,UAAU,KAAM;AAGpB,cAAK,GAAG,WAAW,KAAM,OAAQ,GAAI;AAEpC;AAAA,UAED;AAGA,cAAK,GAAG,MAAM,KAAM,OAAQ,KAAK,GAAG,KAAK,KAAM,OAAQ,GAAI;AAE1D,oBAAQ;AACR,qBAAS;AACT;AAAA,UAED;AAEA,cAAK,GAAG,MAAM,KAAM,OAAQ,GAAI;AAE/B,oBAAQ;AACR,qBAAS;AACT;AAAA,UAED;AAGA,cAAK,GAAG,MAAM,KAAM,OAAQ,GAAI;AAE/B,gBAAK,WAAY;AAEhB,+BAAkB,SAAS,GAAG,MAAO;AAAA,YAEtC;AAEA,wBAAY;AAAA,UAEb;AAAA,QAED;AAGA,YAAK,UAAU,KAAM;AAEpB,cAAK,GAAG,MAAM,KAAM,OAAQ,GAAI;AAE/B,sBAAU;AACV;AAAA,UAED;AAEA,cAAK,GAAG,MAAM,KAAM,OAAQ,GAAI;AAE/B,sBAAU;AACV,oBAAQ;AACR;AAAA,UAED;AAEA,cAAK,GAAG,IAAI,KAAM,OAAQ,GAAI;AAE7B,oBAAQ;AACR;AAAA,UAED;AAGA,cAAK,GAAG,KAAK,KAAM,OAAQ,KACtB,OAAO,WAAW,KAClB,GAAG,KAAK,KAAM,OAAQ,EAAI,GAAI;AAElC,6BAAkB,SAAS,GAAG,MAAO;AAAA,UAEtC;AAAA,QAED;AAGA,YAAK,UAAU,OAAQ;AAEtB,cAAK,GAAG,MAAM,KAAM,OAAQ,GAAI;AAE/B,sBAAU;AACV;AAAA,UAED;AAEA,cAAK,GAAG,IAAI,KAAM,OAAQ,GAAI;AAE7B,oBAAQ;AACR;AAAA,UAED;AAGA,cAAK,GAAG,MAAM,KAAM,OAAQ,KAAK,OAAQ,OAAO,SAAS,OAAQ,KAAM;AAEtE,6BAAkB,SAAS,GAAG,MAAO;AAAA,UAEtC;AAAA,QAED;AAGA,YAAK,UAAU,KAAM;AAEpB,cAAK,GAAG,MAAM,KAAM,OAAQ,GAAI;AAE/B,wBAAY;AACZ;AAAA,UAED;AAEA,cAAK,GAAG,KAAK,KAAM,OAAQ,GAAI;AAE9B,gBAAK,aAAa,IAAK;AAEtB,0BAAY;AACZ;AAAA,YAED;AAEA,gBAAK,SAAS,WAAW,KAAK,GAAG,KAAK,KAAM,QAAS,GAAI;AAExD,+BAAkB,SAAS,GAAG,MAAO;AAAA,YAEtC;AAAA,UAED;AAAA,QAED;AAIA,YAAK,GAAG,WAAW,KAAM,OAAQ,GAAI;AAEpC,oBAAU;AACV,kBAAQ;AACR,sBAAY;AAAA,QAEb,WAAY,GAAG,MAAM,KAAM,OAAQ,GAAI;AAEtC,oBAAU;AACV,kBAAQ;AACR,sBAAY;AAAA,QAEb,WAAY,GAAG,KAAK,KAAM,OAAQ,GAAI;AAErC,oBAAU;AACV,kBAAQ;AACR,mBAAS;AAAA,QAEV,WAAY,GAAG,MAAM,KAAM,OAAQ,GAAI;AAEtC,oBAAU;AACV,kBAAQ;AACR,mBAAS;AAAA,QAEV,OAAO;AAEN,2BAAkB,SAAS,GAAG,MAAO;AAAA,QAEtC;AAAA,MAED;AAGA,gBAAU;AAEV,aAAO;AAAA,IAER;AAIA,UAAM,QAAQ,CAAE,MAAM,MAAM,MAAM,MAAM,MAAM,IAAK;AAGnD,UAAM,iBAAiB;AAAA,MAEtB,MAAM;AAAA,QACL,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM,IAAI;AAAA,QACV,MAAM,KAAK;AAAA,QACX,MAAM,IAAI;AAAA,QACV,MAAM;AAAA,MACP;AAAA,MACA,MAAM;AAAA,QACL,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM,IAAI;AAAA,QACV,MAAM,KAAK;AAAA,QACX,MAAM,IAAI;AAAA,QACV,MAAM;AAAA,MACP;AAAA,MACA,MAAM;AAAA,QACL,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,MACP;AAAA,MACA,MAAM;AAAA,QACL,MAAM,OAAO;AAAA,QACb,MAAM,OAAO;AAAA,QACb,MAAM,IAAI;AAAA,QACV,MAAM;AAAA,QACN,MAAM,IAAI;AAAA,QACV,MAAM;AAAA,MACP;AAAA,MACA,MAAM;AAAA,QACL,MAAM,OAAO;AAAA,QACb,MAAM,OAAO;AAAA,QACb,MAAM,IAAI;AAAA,QACV,MAAM,KAAK;AAAA,QACX,MAAM;AAAA,QACN,MAAM;AAAA,MACP;AAAA,MACA,MAAM;AAAA,QACL,MAAM;AAAA,MACP;AAAA,IAED;AAEA,iCAA8B,QAAS;AAEtC,UAAI,UAAU;AAEd,UAAK,OAAO,WAAW,YAAY,kBAAkB,QAAS;AAE7D,iBAAU,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAO;AAEhD,gBAAM,IAAI,MAAO;AAEjB,cAAK,OAAO,SAAU,CAAE,GAAI;AAE3B,sBAAU;AACV,qBAAS,OAAO,UAAW,GAAG,OAAO,SAAS,EAAE,MAAO;AACvD;AAAA,UAED;AAAA,QAED;AAAA,MAED;AAEA,UAAI,QAAQ;AAEZ,UAAK,YAAY,QAAQ,MAAM,gBAAgB,MAAO;AAIrD,gBAAQ,eAAgB,MAAQ,MAAM,eAAgB,MAAM;AAAA,MAE7D,OAAO;AAEN,gBAAQ,eAAgB,SAAW,MAAM;AAEzC,YAAK,QAAQ,GAAI;AAIhB,kBAAQ,eAAgB,SAAW,QAAS,MAAM;AAAA,QAEnD;AAAA,MAED;AAEA,aAAO,QAAQ,WAAY,MAAO;AAAA,IAEnC;AAIA,8BAA2B,MAAO;AAEjC,UAAK,CAAI,MAAK,aAAc,WAAY,KAAO,KAAK,aAAa,SAAW,MAAK,aAAc,GAAI,KAAK,KAAK,aAAc,GAAI,KAAU;AAExI,eAAO;AAAA,MAER;AAEA,YAAM,YAAY,mBAAoB,IAAK;AAE3C,UAAK,eAAe,SAAS,GAAI;AAEhC,kBAAU,YAAa,eAAgB,eAAe,SAAS,EAAI;AAAA,MAEpE;AAEA,uBAAiB,KAAM,SAAU;AACjC,qBAAe,KAAM,SAAU;AAE/B,aAAO;AAAA,IAER;AAEA,gCAA6B,MAAO;AAEnC,YAAM,YAAY,IAAI,QAAQ;AAC9B,YAAM,oBAAmB;AAEzB,UAAK,KAAK,aAAa,SAAW,MAAK,aAAc,GAAI,KAAK,KAAK,aAAc,GAAI,IAAM;AAE1F,cAAM,KAAK,oBAAqB,KAAK,aAAc,GAAI,CAAE;AACzD,cAAM,KAAK,oBAAqB,KAAK,aAAc,GAAI,CAAE;AAEzD,kBAAU,UAAW,IAAI,EAAG;AAAA,MAE7B;AAEA,UAAK,KAAK,aAAc,WAAY,GAAI;AAEvC,cAAM,kBAAkB,KAAK,aAAc,WAAY,EAAE,MAAO,GAAI;AAEpE,iBAAU,SAAS,gBAAgB,SAAS,GAAG,UAAU,GAAG,UAAY;AAEvE,gBAAM,gBAAgB,gBAAiB,QAAS,KAAK;AAErD,cAAK,kBAAkB;AAAK;AAE5B,gBAAM,aAAa,cAAc,QAAS,GAAI;AAC9C,gBAAM,cAAc,cAAc;AAElC,cAAK,aAAa,KAAK,aAAa,aAAc;AAEjD,kBAAM,gBAAgB,cAAc,OAAQ,GAAG,UAAW;AAE1D,kBAAM,QAAQ,YAAa,cAAc,OAAQ,aAAa,GAAG,cAAc,aAAa,CAAE,CAAE;AAEhG,8BAAiB,SAAS;AAE1B,oBAAS;AAAA,mBAEH;AAEJ,oBAAK,MAAM,UAAU,GAAI;AAExB,wBAAM,KAAK,MAAO;AAClB,sBAAI,KAAK;AAET,sBAAK,MAAM,UAAU,GAAI;AAExB,yBAAK,MAAO;AAAA,kBAEb;AAEA,oCAAiB,UAAW,IAAI,EAAG;AAAA,gBAEpC;AAEA;AAAA,mBAEI;AAEJ,oBAAK,MAAM,UAAU,GAAI;AAExB,sBAAI,QAAQ;AACZ,sBAAI,KAAK;AACT,sBAAI,KAAK;AAGT,0BAAQ,CAAE,MAAO,KAAM,KAAK,KAAK;AAEjC,sBAAK,MAAM,UAAU,GAAI;AAGxB,yBAAK,MAAO;AACZ,yBAAK,MAAO;AAAA,kBAEb;AAGA,iCAAe,SAAS,EAAE,UAAW,CAAE,IAAI,CAAE,EAAG;AAChD,iCAAe,SAAS,EAAE,OAAQ,KAAM;AACxC,iCAAe,iBAAkB,gBAAgB,cAAe;AAChE,iCAAe,SAAS,EAAE,UAAW,IAAI,EAAG;AAC5C,oCAAiB,iBAAkB,gBAAgB,cAAe;AAAA,gBAEnE;AAEA;AAAA,mBAEI;AAEJ,oBAAK,MAAM,UAAU,GAAI;AAExB,wBAAM,SAAS,MAAO;AACtB,sBAAI,SAAS;AAEb,sBAAK,MAAM,UAAU,GAAI;AAExB,6BAAS,MAAO;AAAA,kBAEjB;AAEA,oCAAiB,MAAO,QAAQ,MAAO;AAAA,gBAExC;AAEA;AAAA,mBAEI;AAEJ,oBAAK,MAAM,WAAW,GAAI;AAEzB,oCAAiB,IAChB,GAAG,KAAK,IAAK,MAAO,KAAM,KAAK,KAAK,GAAI,GAAG,GAC3C,GAAG,GAAG,GACN,GAAG,GAAG,CACP;AAAA,gBAED;AAEA;AAAA,mBAEI;AAEJ,oBAAK,MAAM,WAAW,GAAI;AAEzB,oCAAiB,IAChB,GAAG,GAAG,GACN,KAAK,IAAK,MAAO,KAAM,KAAK,KAAK,GAAI,GAAG,GAAG,GAC3C,GAAG,GAAG,CACP;AAAA,gBAED;AAEA;AAAA,mBAEI;AAEJ,oBAAK,MAAM,WAAW,GAAI;AAEzB,oCAAiB,IAChB,MAAO,IAAK,MAAO,IAAK,MAAO,IAC/B,MAAO,IAAK,MAAO,IAAK,MAAO,IAC/B,GAAG,GAAG,CACP;AAAA,gBAED;AAEA;AAAA;AAAA,UAIH;AAEA,oBAAU,YAAa,iBAAiB;AAAA,QAEzC;AAAA,MAED;AAEA,aAAO;AAAA,IAER;AAEA,2BAAwB,MAAM,GAAI;AAEjC,0BAAqB,IAAK;AAEzB,eAAO,IAAK,GAAG,GAAG,GAAG,GAAG,CAAE,EAAE,aAAc,CAAE;AAE5C,WAAG,IAAK,OAAO,GAAG,OAAO,CAAE;AAAA,MAE5B;AAEA,YAAM,YAAY,mBAAoB,CAAE;AAExC,YAAM,WAAW,KAAK;AAEtB,eAAU,IAAI,GAAG,IAAI,SAAS,QAAQ,IAAI,GAAG,KAAO;AAEnD,cAAM,UAAU,SAAU;AAC1B,cAAM,SAAS,QAAQ;AAEvB,iBAAU,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAO;AAE1C,gBAAM,QAAQ,OAAQ;AAEtB,cAAK,MAAM,aAAc;AAExB,uBAAY,MAAM,EAAG;AACrB,uBAAY,MAAM,EAAG;AAAA,UAEtB,WAAY,MAAM,oBAAqB;AAEtC,uBAAY,MAAM,EAAG;AACrB,uBAAY,MAAM,EAAG;AACrB,uBAAY,MAAM,EAAG;AACrB,uBAAY,MAAM,EAAG;AAAA,UAEtB,WAAY,MAAM,wBAAyB;AAE1C,uBAAY,MAAM,EAAG;AACrB,uBAAY,MAAM,EAAG;AACrB,uBAAY,MAAM,EAAG;AAAA,UAEtB,WAAY,MAAM,gBAAiB;AAElC,gBAAK,WAAY;AAEhB,sBAAQ,KAAM,4EAA6E;AAAA,YAE5F;AAEA,mBAAO,IAAK,MAAM,IAAI,MAAM,EAAG;AAC/B,uBAAY,MAAO;AACnB,kBAAM,KAAK,OAAO;AAClB,kBAAM,KAAK,OAAO;AAElB,kBAAM,WAAW,mBAAoB,CAAE;AACvC,kBAAM,WAAW,mBAAoB,CAAE;AAAA,UAExC;AAAA,QAED;AAAA,MAED;AAAA,IAED;AAEA,gCAA6B,GAAI;AAEhC,aAAO,EAAE,SAAU,OAAQ,KAAK,EAAE,SAAU,OAAQ;AAAA,IAErD;AAEA,gCAA6B,GAAI;AAEhC,YAAM,KAAK,EAAE;AACb,aAAO,KAAK,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,EAAI;AAAA,IAEzD;AAEA,gCAA6B,GAAI;AAEhC,YAAM,KAAK,EAAE;AACb,aAAO,KAAK,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,EAAI;AAAA,IAEzD;AAIA,UAAM,QAAQ,CAAC;AACf,UAAM,cAAc,CAAC;AAErB,UAAM,iBAAiB,CAAC;AAExB,UAAM,iBAAiB,IAAI,QAAQ;AACnC,UAAM,iBAAiB,IAAI,QAAQ;AACnC,UAAM,iBAAiB,IAAI,QAAQ;AACnC,UAAM,iBAAiB,IAAI,QAAQ;AACnC,UAAM,SAAS,IAAI,QAAQ;AAC3B,UAAM,SAAS,IAAI,QAAQ;AAE3B,UAAM,mBAAmB,IAAI,QAAQ;AAErC,UAAM,MAAM,IAAI,UAAU,EAAE,gBAAiB,MAAM,eAAgB;AAEnE,cAAW,IAAI,iBAAiB;AAAA,MAC/B,MAAM;AAAA,MACN,aAAa;AAAA,MACb,eAAe;AAAA,MACf,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,eAAe;AAAA,MACf,kBAAkB;AAAA,IACnB,CAAE;AAEF,UAAM,OAAO,EAAE,OAAc,KAAK,IAAI,gBAAgB;AAGtD,WAAO;AAAA,EAER;AAAA,SAEO,aAAc,WAAY;AAKhC,UAAM,YAAY;AAElB,UAAM,2BAA2B;AAAA,MAChC,QAAQ;AAAA,MACR,aAAa;AAAA,MACb,SAAS;AAAA,MACT,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,IACT;AAEA,UAAM,iBAAiB;AAAA,MACtB,KAAK,yBAAyB;AAAA,MAC9B,GAAG;AAAA,IACJ;AAEA,kCAA+B,IAAI,IAAI,IAAI,IAAK;AAE/C,YAAM,KAAK,GAAG;AACd,YAAM,KAAK,GAAG;AACd,YAAM,KAAK,GAAG;AACd,YAAM,KAAK,GAAG;AACd,YAAM,KAAK,GAAG;AACd,YAAM,KAAK,GAAG;AACd,YAAM,KAAK,GAAG;AACd,YAAM,KAAK,GAAG;AACd,YAAM,OAAS,MAAK,MAAS,MAAK,MAAS,MAAK,MAAS,MAAK;AAC9D,YAAM,OAAS,MAAK,MAAS,MAAK,MAAS,MAAK,MAAS,MAAK;AAC9D,YAAM,QAAU,MAAK,MAAS,MAAK,MAAS,MAAK,MAAS,MAAK;AAC/D,YAAM,KAAK,OAAO;AAClB,YAAM,KAAK,OAAO;AAElB,UAAS,UAAU,KAAS,SAAS,KAAW,MAAM,KAAS,MAAM,KAAS,KAAK,KAAS,KAAK,GAAM;AAItG,eAAO;AAAA,MAER,WAAc,SAAS,KAAS,UAAU,GAAM;AAK/C,iBAAU,IAAI,GAAG,IAAI,GAAG,KAAO;AAE9B,wBAAe,MAAM,IAAI,KAAK,IAAI,IAAI,EAAG;AAEzC,cAAK,eAAe,OAAO,yBAAyB,QAAS;AAE5D,kBAAM,QAAU,MAAM,IAAI,KAAK;AAC/B,mBAAO,EAAE,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,GAAG,eAAe,EAAE;AAAA,UAEtD,WAAY,eAAe,OAAO,yBAAyB,SAAU;AAEpE,kBAAM,IAAI,CAAM,MAAK,eAAe,IAAM,MAAK,KAAO,YAAa,EAAG;AACtE,kBAAM,IAAI,CAAM,MAAK,eAAe,IAAM,MAAK,KAAO,YAAa,EAAG;AACtE,mBAAO,EAAE,GAAM,GAAM,GAAG,eAAe,EAAG;AAAA,UAE3C;AAAA,QAED;AAEA,eAAO;AAAA,MAER,OAAO;AAIN,iBAAU,IAAI,GAAG,IAAI,GAAG,KAAO;AAE9B,wBAAe,MAAM,IAAI,KAAK,IAAI,IAAI,EAAG;AAEzC,cAAK,eAAe,OAAO,yBAAyB,QAAS;AAE5D,kBAAM,QAAU,MAAM,IAAI,KAAK;AAC/B,mBAAO,EAAE,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,GAAG,eAAe,EAAE;AAAA,UAEtD;AAAA,QAED;AAEA,cAAM,IAAI,CAAM,MAAK,KAAO,MAAK,KAAO,YAAa,EAAG;AACxD,cAAM,IAAI,CAAM,MAAK,KAAO,MAAK,KAAO,YAAa,EAAG;AACxD,eAAO,EAAE,GAAM,GAAM,GAAG,GAAG;AAAA,MAE5B;AAAA,IAED;AAEA,2BAAwB,GAAG,WAAW,SAAU;AAE/C,YAAM,KAAK,QAAQ,IAAI,UAAU;AACjC,YAAM,KAAK,QAAQ,IAAI,UAAU;AACjC,YAAM,KAAK,EAAE,IAAI,UAAU;AAC3B,YAAM,KAAK,EAAE,IAAI,UAAU;AAC3B,YAAM,KAAK,KAAK,KAAK,KAAK;AAE1B,UAAO,EAAE,MAAM,UAAU,KAAS,EAAE,MAAM,UAAU,GAAM;AAEzD,uBAAe,MAAM,yBAAyB;AAC9C,uBAAe,IAAI;AACnB;AAAA,MAED;AAEA,UAAO,EAAE,MAAM,QAAQ,KAAS,EAAE,MAAM,QAAQ,GAAM;AAErD,uBAAe,MAAM,yBAAyB;AAC9C,uBAAe,IAAI;AACnB;AAAA,MAED;AAEA,UAAK,KAAK,CAAE,OAAO,SAAU;AAE5B,uBAAe,MAAM,yBAAyB;AAC9C;AAAA,MAED;AAEA,UAAK,KAAK,OAAO,SAAU;AAE1B,uBAAe,MAAM,yBAAyB;AAC9C;AAAA,MAGD;AAEA,UAAS,KAAK,KAAO,KAAW,KAAK,KAAO,GAAM;AAEjD,uBAAe,MAAM,yBAAyB;AAC9C;AAAA,MAED;AAEA,UAAO,KAAK,KAAM,KAAK,KAAK,KAAK,EAAG,IAAQ,KAAK,KAAM,KAAK,KAAK,KAAK,EAAG,GAAM;AAE9E,uBAAe,MAAM,yBAAyB;AAC9C;AAAA,MAED;AAEA,UAAI;AAEJ,UAAK,OAAO,GAAI;AAEf,YAAI,KAAK;AAAA,MAEV,OAAO;AAEN,YAAI,KAAK;AAAA,MAEV;AAEA,qBAAe,MAAM,yBAAyB;AAC9C,qBAAe,IAAI;AAAA,IAEpB;AAEA,8BAA2B,OAAO,OAAQ;AAEzC,YAAM,mBAAmB,CAAC;AAC1B,YAAM,gBAAgB,CAAC;AAEvB,eAAU,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAW;AAErD,cAAM,iBAAiB,MAAO,QAAQ;AACtC,cAAM,eAAe,MAAO;AAE5B,iBAAU,SAAS,GAAG,SAAS,MAAM,QAAQ,UAAY;AAExD,gBAAM,iBAAiB,MAAO,SAAS;AACvC,gBAAM,eAAe,MAAO;AAE5B,gBAAM,eAAe,qBAAsB,gBAAgB,cAAc,gBAAgB,YAAa;AAEtG,cAAK,iBAAiB,QAAQ,iBAAiB,KAAM,OAAK,EAAE,KAAK,aAAa,IAAI,OAAO,WAAW,EAAE,KAAK,aAAa,IAAI,OAAO,OAAQ,MAAM,QAAY;AAE5J,6BAAiB,KAAM,YAAa;AACpC,0BAAc,KAAM,IAAI,QAAS,aAAa,GAAG,aAAa,CAAE,CAAE;AAAA,UAEnE;AAAA,QAED;AAAA,MAED;AAEA,aAAO;AAAA,IAER;AAEA,sCAAmC,UAAU,aAAa,OAAQ;AAEjE,YAAM,SAAS,IAAI,QAAQ;AAC3B,kBAAY,UAAW,MAAO;AAE9B,YAAM,mBAAmB,CAAC;AAE1B,YAAM,QAAS,UAAQ;AAKtB,YAAK,KAAK,YAAY,cAAe,MAAO,GAAI;AAE/C,gBAAM,gBAAgB,iBAAkB,UAAU,KAAK,MAAO;AAE9D,wBAAc,QAAS,OAAK;AAE3B,6BAAiB,KAAM,EAAE,YAAY,KAAK,YAAY,MAAM,KAAK,MAAM,OAAO,EAAE,CAAE;AAAA,UAEnF,CAAE;AAAA,QAEH;AAAA,MAED,CAAE;AAEF,uBAAiB,KAAM,CAAE,IAAI,OAAQ;AAEpC,eAAO,GAAG,MAAM,IAAI,GAAG,MAAM;AAAA,MAE9B,CAAE;AAEF,aAAO;AAAA,IAER;AAEA,sBAAmB,YAAY,UAAU,eAAc,eAAc,WAAY;AAEhF,UAAK,cAAc,QAAQ,cAAc,UAAa,cAAc,IAAK;AAExE,oBAAY;AAAA,MAEb;AAEA,YAAM,oBAAoB,IAAI,QAAQ;AACtC,iBAAW,YAAY,UAAW,iBAAkB;AAEpD,YAAM,WAAW,CAAE,IAAI,QAAS,eAAc,kBAAkB,CAAE,GAAG,IAAI,QAAS,eAAc,kBAAkB,CAAE,CAAE;AAEtH,YAAM,wBAAwB,yBAA0B,UAAU,WAAW,aAAa,QAAS;AAEnG,4BAAsB,KAAM,CAAE,IAAI,OAAQ;AAEzC,eAAO,GAAG,MAAM,IAAI,GAAG,MAAM;AAAA,MAE9B,CAAE;AAEF,YAAM,oBAAoB,CAAC;AAC3B,YAAM,qBAAqB,CAAC;AAE5B,4BAAsB,QAAS,QAAK;AAEnC,YAAK,GAAE,eAAe,WAAW,YAAa;AAE7C,4BAAkB,KAAM,EAAE;AAAA,QAE3B,OAAO;AAEN,6BAAmB,KAAM,EAAE;AAAA,QAE5B;AAAA,MAED,CAAE;AAEF,YAAM,eAAe,kBAAmB,GAAI,MAAM;AAGlD,YAAM,QAAQ,CAAC;AACf,UAAI,IAAI;AAER,aAAQ,IAAI,mBAAmB,UAAU,mBAAoB,GAAI,MAAM,IAAI,cAAe;AAEzF,YAAK,MAAM,SAAS,KAAK,MAAO,MAAM,SAAS,OAAQ,mBAAoB,GAAI,YAAa;AAE3F,gBAAM,IAAI;AAAA,QAEX,OAAO;AAEN,gBAAM,KAAM,mBAAoB,GAAI,UAAW;AAAA,QAEhD;AAEA;AAAA,MAED;AAEA,YAAM,KAAM,WAAW,UAAW;AAElC,UAAK,cAAc,WAAY;AAE9B,cAAM,SAAS,MAAM,SAAS,MAAM,IAAI,OAAO;AAC/C,cAAM,YAAY,MAAO,MAAM,SAAS;AAExC,eAAO,EAAE,YAAY,WAAW,YAAY,QAAgB,KAAK,UAAU;AAAA,MAE5E,WAAY,cAAc,WAAY;AAGrC,YAAI,SAAS;AACb,YAAI,YAAY;AAChB,YAAI,cAAc;AAElB,iBAAU,KAAI,GAAG,KAAI,MAAM,QAAQ,MAAO;AAEzC,gBAAM,cAAa,MAAO;AAC1B,cAAK,QAAS;AAEb,0BAAc,SAAU,aAAa;AACrC,qBAAS;AACT,wBAAY;AAAA,UAEb,WAAY,gBAAgB,SAAU,aAAa,MAAO;AAEzD,0BAAc,SAAU,aAAa;AACrC,qBAAS;AAAA,UAEV;AAAA,QAED;AAEA,eAAO,EAAE,YAAY,WAAW,YAAY,QAAgB,KAAK,UAAU;AAAA,MAE5E,OAAO;AAEN,gBAAQ,KAAM,iBAAiB,YAAY,iCAAkC;AAAA,MAE9E;AAAA,IAED;AASA,QAAI,aAAa;AAEjB,QAAI,eAAe;AACnB,QAAI,eAAe,CAAE;AAErB,QAAI,cAAc,UAAU,SAAS,IAAK,OAAK;AAE9C,YAAM,SAAS,EAAE,UAAU;AAC3B,UAAI,OAAO,CAAE;AACb,UAAI,OAAO;AACX,UAAI,OAAO,CAAE;AACb,UAAI,OAAO;AAIX,eAAU,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAO;AAE1C,cAAM,KAAI,OAAQ;AAElB,YAAK,GAAE,IAAI,MAAO;AAEjB,iBAAO,GAAE;AAAA,QAEV;AAEA,YAAK,GAAE,IAAI,MAAO;AAEjB,iBAAO,GAAE;AAAA,QAEV;AAEA,YAAK,GAAE,IAAI,MAAO;AAEjB,iBAAO,GAAE;AAAA,QAEV;AAEA,YAAK,GAAE,IAAI,MAAO;AAEjB,iBAAO,GAAE;AAAA,QAEV;AAAA,MAED;AAGA,UAAK,gBAAgB,MAAO;AAE3B,uBAAe,OAAO;AAAA,MAEvB;AAEA,UAAK,gBAAgB,MAAO;AAE3B,uBAAe,OAAO;AAAA,MAEvB;AAEA,aAAO,EAAE,QAAQ,EAAE,QAAQ,QAAgB,MAAM,WAAW,YAAa,MAAO,GAAG,YAAY,cAAe,aAAa,IAAI,KAAM,IAAI,QAAS,MAAM,IAAK,GAAG,IAAI,QAAS,MAAM,IAAK,CAAE,EAAE;AAAA,IAE7L,CAAE;AAEF,kBAAc,YAAY,OAAQ,QAAM,GAAG,OAAO,SAAS,CAAE;AAG7D,UAAM,UAAU,YAAY,IAAK,OAAK,SAAU,GAAG,aAAa,cAAc,cAAc,UAAU,SAAS,MAAM,QAAS,CAAE;AAGhI,UAAM,iBAAiB,CAAC;AACxB,gBAAY,QAAS,OAAK;AAEzB,YAAM,WAAW,QAAS,EAAE;AAE5B,UAAK,CAAE,SAAS,QAAS;AAExB,cAAM,QAAQ,IAAI,MAAM;AACxB,cAAM,SAAS,EAAE;AACjB,cAAM,QAAQ,QAAQ,OAAQ,OAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,UAAW;AACtE,cAAM,QAAS,OAAK;AAEnB,gBAAM,OAAO,YAAa,EAAE;AAC5B,gBAAM,OAAO,IAAI,KAAK;AACtB,eAAK,SAAS,KAAK;AACnB,gBAAM,MAAM,KAAM,IAAK;AAAA,QAExB,CAAE;AACF,uBAAe,KAAM,KAAM;AAAA,MAE5B;AAAA,IAED,CAAE;AAEF,WAAO;AAAA,EAER;AAAA,SAEO,eAAgB,OAAO,OAAO,UAAU,SAAS,YAAa;AASpE,YAAQ,UAAU,SAAY,QAAQ;AACtC,YAAQ,UAAU,SAAY,QAAQ;AACtC,eAAW,aAAa,SAAY,WAAW;AAC/C,cAAU,YAAY,SAAY,UAAU;AAC5C,iBAAa,eAAe,SAAY,aAAa;AAErD,WAAO;AAAA,MACN,aAAa;AAAA,MACb,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,eAAe;AAAA,MACf,kBAAkB;AAAA,IACnB;AAAA,EAED;AAAA,SAEO,eAAgB,QAAQ,OAAO,cAAc,aAAc;AAUjE,UAAM,WAAW,CAAC;AAClB,UAAM,UAAU,CAAC;AACjB,UAAM,MAAM,CAAC;AAEb,QAAK,UAAU,0BAA2B,QAAQ,OAAO,cAAc,aAAa,UAAU,SAAS,GAAI,MAAM,GAAI;AAEpH,aAAO;AAAA,IAER;AAEA,UAAM,WAAW,IAAI,eAAe;AACpC,aAAS,aAAc,YAAY,IAAI,uBAAwB,UAAU,CAAE,CAAE;AAC7E,aAAS,aAAc,UAAU,IAAI,uBAAwB,SAAS,CAAE,CAAE;AAC1E,aAAS,aAAc,MAAM,IAAI,uBAAwB,KAAK,CAAE,CAAE;AAElE,WAAO;AAAA,EAER;AAAA,SAEO,0BAA2B,QAAQ,OAAO,cAAc,aAAa,UAAU,SAAS,KAAK,cAAe;AASlH,UAAM,WAAW,IAAI,QAAQ;AAC7B,UAAM,WAAW,IAAI,QAAQ;AAC7B,UAAM,WAAW,IAAI,QAAQ;AAC7B,UAAM,WAAW,IAAI,QAAQ;AAC7B,UAAM,WAAW,IAAI,QAAQ;AAC7B,UAAM,WAAW,IAAI,QAAQ;AAC7B,UAAM,WAAW,IAAI,QAAQ;AAC7B,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,UAAU,IAAI,QAAQ;AAC5B,UAAM,UAAU,IAAI,QAAQ;AAC5B,UAAM,gBAAgB,IAAI,QAAQ;AAClC,UAAM,gBAAgB,IAAI,QAAQ;AAClC,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,aAAa,IAAI,QAAQ;AAE/B,mBAAe,iBAAiB,SAAY,eAAe;AAC3D,kBAAc,gBAAgB,SAAY,cAAc;AACxD,mBAAe,iBAAiB,SAAY,eAAe;AAG3D,aAAS,uBAAwB,MAAO;AAExC,UAAM,YAAY,OAAO;AAEzB,QAAK,YAAY;AAAI,aAAO;AAE5B,UAAM,WAAW,OAAQ,GAAI,OAAQ,OAAQ,YAAY,EAAI;AAE7D,QAAI;AACJ,QAAI,gBAAgB,OAAQ;AAC5B,QAAI;AAEJ,UAAM,eAAe,MAAM,cAAc;AAEzC,UAAM,SAAS,IAAM,aAAY;AACjC,QAAI,KAAK,GAAG;AAEZ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,0BAA0B;AAE9B,QAAI,cAAc;AAClB,QAAI,oBAAoB,eAAe;AACvC,QAAI,sBAAsB,eAAe;AAGzC,cAAW,OAAQ,IAAK,OAAQ,IAAK,QAAS,EAAE,eAAgB,YAAa;AAC7E,eAAW,KAAM,OAAQ,EAAI,EAAE,IAAK,QAAS;AAC7C,eAAW,KAAM,OAAQ,EAAI,EAAE,IAAK,QAAS;AAC7C,YAAQ,KAAM,UAAW;AACzB,YAAQ,KAAM,UAAW;AAEzB,aAAU,SAAS,GAAG,SAAS,WAAW,UAAY;AAErD,qBAAe,OAAQ;AAGvB,UAAK,WAAW,YAAY,GAAI;AAE/B,YAAK,UAAW;AAGf,sBAAY,OAAQ;AAAA,QAErB;AAAO,sBAAY;AAAA,MAEpB,OAAO;AAEN,oBAAY,OAAQ,SAAS;AAAA,MAE9B;AAGA,YAAM,UAAU;AAChB,gBAAW,eAAe,cAAc,OAAQ;AAEhD,eAAS,KAAM,OAAQ,EAAE,eAAgB,YAAa;AACtD,oBAAc,KAAM,YAAa,EAAE,IAAK,QAAS;AACjD,oBAAc,KAAM,YAAa,EAAE,IAAK,QAAS;AAEjD,WAAK,KAAK;AAEV,0BAAoB;AAEpB,UAAK,cAAc,QAAY;AAG9B,kBAAW,cAAc,WAAW,QAAS;AAE7C,iBAAS,KAAM,QAAS,EAAE,eAAgB,YAAa;AACvD,mBAAW,KAAM,YAAa,EAAE,IAAK,QAAS;AAC9C,mBAAW,KAAM,YAAa,EAAE,IAAK,QAAS;AAE9C,2BAAmB;AACnB,iBAAS,WAAY,WAAW,aAAc;AAC9C,YAAK,QAAQ,IAAK,QAAS,IAAI,GAAI;AAElC,6BAAmB;AAAA,QAEpB;AAEA,YAAK,WAAW;AAAI,oCAA0B;AAE9C,iBAAS,WAAY,WAAW,YAAa;AAC7C,iBAAS,UAAU;AACnB,cAAM,MAAM,KAAK,IAAK,QAAQ,IAAK,QAAS,CAAE;AAG9C,YAAK,QAAQ,GAAI;AAGhB,gBAAM,YAAY,eAAe;AACjC,mBAAS,eAAgB,CAAE,SAAU;AACrC,mBAAS,WAAY,cAAc,aAAc;AACjD,mBAAS,KAAM,QAAS,EAAE,UAAW,SAAU,EAAE,IAAK,QAAS;AAC/D,qBAAW,KAAM,QAAS,EAAE,OAAO;AACnC,gBAAM,eAAe,SAAS,OAAO;AACrC,gBAAM,oBAAoB,SAAS,OAAO;AAC1C,mBAAS,aAAc,iBAAkB;AACzC,mBAAS,WAAY,WAAW,YAAa;AAC7C,gBAAM,oBAAoB,SAAS,OAAO;AAC1C,mBAAS,aAAc,iBAAkB;AAEzC,cAAK,SAAS,IAAK,UAAW,IAAI,qBAAqB,SAAS,IAAK,UAAW,IAAI,mBAAoB;AAEvG,gCAAoB;AAAA,UAErB;AAEA,qBAAW,KAAM,QAAS,EAAE,IAAK,YAAa;AAC9C,qBAAW,IAAK,YAAa;AAE7B,oBAAU;AAEV,cAAK,mBAAoB;AAExB,gBAAK,kBAAmB;AAEvB,yBAAW,KAAM,UAAW;AAC5B,4BAAc,KAAM,UAAW;AAAA,YAEhC,OAAO;AAEN,yBAAW,KAAM,UAAW;AAC5B,4BAAc,KAAM,UAAW;AAAA,YAEhC;AAAA,UAED,OAAO;AAIN,iCAAqB;AAAA,UAEtB;AAEA,kBAAS,MAAM;AAAA,iBAET;AAEJ,uCAA0B,kBAAkB,mBAAmB,EAAG;AAElE;AAAA,iBAEI;AAIJ,sDAAyC,kBAAkB,iBAAkB;AAI7E,kBAAK,kBAAmB;AAEvB,mCAAoB,cAAc,eAAe,YAAY,IAAI,CAAE;AAAA,cAEpE,OAAO;AAEN,mCAAoB,cAAc,YAAY,eAAe,IAAI,CAAE;AAAA,cAEpE;AAEA;AAAA,iBAEI;AAAA,iBACA;AAAA;AAGJ,oBAAM,gBAAkB,eAAe,MAAM,mBAAqB;AAElE,kBAAK,gBAAgB,GAAI;AAIxB,oBAAK,MAAM,mBAAmB,cAAe;AAE5C,2CAA0B,kBAAkB,mBAAmB,EAAG;AAClE;AAAA,gBAED,OAAO;AAIN,0DAAyC,kBAAkB,iBAAkB;AAI7E,sBAAK,kBAAmB;AAEvB,6BAAS,WAAY,YAAY,aAAc,EAAE,eAAgB,aAAc,EAAE,IAAK,aAAc;AACpG,6BAAS,WAAY,YAAY,UAAW,EAAE,eAAgB,aAAc,EAAE,IAAK,UAAW;AAE9F,8BAAW,eAAe,IAAI,CAAE;AAChC,8BAAW,UAAU,IAAI,CAAE;AAC3B,8BAAW,cAAc,IAAI,GAAI;AAEjC,8BAAW,cAAc,IAAI,GAAI;AACjC,8BAAW,UAAU,IAAI,CAAE;AAC3B,8BAAW,UAAU,IAAI,CAAE;AAE3B,8BAAW,cAAc,IAAI,GAAI;AACjC,8BAAW,UAAU,IAAI,CAAE;AAC3B,8BAAW,YAAY,IAAI,CAAE;AAAA,kBAE9B,OAAO;AAEN,6BAAS,WAAY,YAAY,aAAc,EAAE,eAAgB,aAAc,EAAE,IAAK,aAAc;AACpG,6BAAS,WAAY,YAAY,UAAW,EAAE,eAAgB,aAAc,EAAE,IAAK,UAAW;AAE9F,8BAAW,eAAe,IAAI,CAAE;AAChC,8BAAW,UAAU,IAAI,CAAE;AAC3B,8BAAW,cAAc,IAAI,GAAI;AAEjC,8BAAW,cAAc,IAAI,GAAI;AACjC,8BAAW,UAAU,IAAI,CAAE;AAC3B,8BAAW,UAAU,IAAI,CAAE;AAE3B,8BAAW,cAAc,IAAI,GAAI;AACjC,8BAAW,UAAU,IAAI,CAAE;AAC3B,8BAAW,YAAY,IAAI,CAAE;AAAA,kBAE9B;AAAA,gBAED;AAAA,cAED,OAAO;AAIN,oBAAK,mBAAoB;AAIxB,sBAAK,kBAAmB;AAEvB,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAE7B,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAAA,kBAE9B,OAAO;AAEN,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAE7B,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAAA,kBAE9B;AAGA,sBAAK,kBAAmB;AAEvB,+BAAW,KAAM,UAAW;AAAA,kBAE7B,OAAO;AAEN,+BAAW,KAAM,UAAW;AAAA,kBAE7B;AAAA,gBAGD,OAAO;AAIN,sBAAK,kBAAmB;AAEvB,8BAAW,eAAe,IAAI,CAAE;AAChC,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,cAAc,IAAI,GAAI;AAEjC,8BAAW,cAAc,IAAI,GAAI;AACjC,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAAA,kBAE9B,OAAO;AAEN,8BAAW,eAAe,IAAI,CAAE;AAChC,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,cAAc,IAAI,GAAI;AAEjC,8BAAW,cAAc,IAAI,GAAI;AACjC,8BAAW,YAAY,IAAI,CAAE;AAC7B,8BAAW,YAAY,IAAI,CAAE;AAAA,kBAE9B;AAAA,gBAED;AAEA,0BAAU;AAAA,cAEX;AAEA;AAAA;AAAA,QAIH,OAAO;AAIN,+BAAqB;AAAA,QAEtB;AAAA,MAED,OAAO;AAIN,6BAAqB;AAAA,MAEtB;AAEA,UAAK,CAAE,YAAY,WAAW,YAAY,GAAI;AAG7C,uBAAgB,OAAQ,IAAK,SAAS,SAAS,kBAAkB,MAAM,EAAG;AAAA,MAE3E;AAIA,WAAK;AAEL,sBAAgB;AAEhB,iBAAW,KAAM,UAAW;AAC5B,iBAAW,KAAM,UAAW;AAAA,IAE7B;AAEA,QAAK,CAAE,UAAW;AAGjB,qBAAgB,cAAc,eAAe,eAAe,kBAAkB,OAAO,EAAG;AAAA,IAEzF,WAAY,qBAAqB,UAAW;AAI3C,UAAI,YAAY;AAChB,UAAI,YAAY;AAEhB,UAAK,4BAA4B,kBAAmB;AAEnD,oBAAY;AACZ,oBAAY;AAAA,MAEb;AAEA,UAAK,kBAAmB;AAEvB,YAAK,WAAW,yBAA0B;AAEzC,oBAAU,QAAS,UAAU,IAAI,CAAE;AACnC,oBAAU,QAAS,UAAU,IAAI,CAAE;AAEnC,cAAK,SAAU;AAEd,sBAAU,QAAS,UAAU,IAAI,CAAE;AAAA,UAEpC;AAAA,QAED;AAAA,MAED,OAAO;AAEN,YAAK,WAAW,CAAE,yBAA0B;AAE3C,oBAAU,QAAS,UAAU,IAAI,CAAE;AACnC,oBAAU,QAAS,UAAU,IAAI,CAAE;AAEnC,cAAK,SAAU;AAEd,sBAAU,QAAS,UAAU,IAAI,CAAE;AAAA,UAEpC;AAAA,QAED;AAAA,MAED;AAAA,IAED;AAEA,WAAO;AAMP,uBAAoB,IAAI,IAAI,QAAS;AAEpC,aAAO,WAAY,IAAI,EAAG;AAC1B,aAAO,OAAO,IAAK,CAAE,OAAO,GAAG,OAAO,CAAE,EAAE,UAAU;AAAA,IAErD;AAEA,uBAAoB,UAAU,GAAG,GAAI;AAEpC,UAAK,UAAW;AAEf,iBAAU,qBAAsB,SAAS;AACzC,iBAAU,oBAAoB,KAAM,SAAS;AAC7C,iBAAU,oBAAoB,KAAM;AAEpC,YAAK,SAAU;AAEd,kBAAS,qBAAsB;AAC/B,kBAAS,oBAAoB,KAAM;AACnC,kBAAS,oBAAoB,KAAM;AAAA,QAEpC;AAEA,6BAAqB;AAErB,YAAK,KAAM;AAEV,cAAK,uBAAwB;AAC7B,cAAK,sBAAsB,KAAM;AAEjC,iCAAuB;AAAA,QAExB;AAAA,MAED;AAEA,qBAAe;AAAA,IAEhB;AAEA,gCAA6B,QAAQ,IAAI,IAAI,GAAG,GAAI;AAKnD,eAAS,KAAM,EAAG,EAAE,IAAK,MAAO,EAAE,UAAU;AAC5C,eAAS,KAAM,EAAG,EAAE,IAAK,MAAO,EAAE,UAAU;AAE5C,UAAI,QAAQ,KAAK;AACjB,YAAM,MAAM,SAAS,IAAK,QAAS;AACnC,UAAK,KAAK,IAAK,GAAI,IAAI;AAAI,gBAAQ,KAAK,IAAK,KAAK,KAAM,GAAI,CAAE;AAE9D,eAAS;AAET,eAAS,KAAM,EAAG;AAElB,eAAU,IAAI,GAAG,KAAK,eAAe,GAAG,IAAI,IAAI,KAAO;AAEtD,iBAAS,KAAM,QAAS,EAAE,aAAc,QAAQ,KAAM;AAEtD,kBAAW,UAAU,GAAG,CAAE;AAC1B,kBAAW,UAAU,GAAG,CAAE;AAC1B,kBAAW,QAAQ,GAAG,GAAI;AAE1B,iBAAS,KAAM,QAAS;AAAA,MAEzB;AAEA,gBAAW,UAAU,GAAG,CAAE;AAC1B,gBAAW,IAAI,GAAG,CAAE;AACpB,gBAAW,QAAQ,GAAG,GAAI;AAAA,IAE3B;AAEA,oCAAgC;AAE/B,gBAAW,YAAY,IAAI,CAAE;AAC7B,gBAAW,YAAY,IAAI,CAAE;AAC7B,gBAAW,eAAe,IAAI,CAAE;AAEhC,gBAAW,YAAY,IAAI,CAAE;AAC7B,gBAAW,eAAe,IAAI,CAAE;AAChC,gBAAW,eAAe,IAAI,CAAE;AAAA,IAEjC;AAEA,sCAAmC,mBAAkB,oBAAmB,GAAI;AAE3E,UAAK,oBAAoB;AAIxB,YAAK,mBAAmB;AAIvB,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAEhC,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAChC,oBAAW,YAAY,IAAI,CAAE;AAI7B,oBAAW,eAAe,GAAG,CAAE;AAC/B,oBAAW,YAAY,GAAG,CAAE;AAC5B,oBAAW,YAAY,GAAG,GAAI;AAAA,QAE/B,OAAO;AAIN,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAEhC,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAIhC,oBAAW,eAAe,GAAG,CAAE;AAC/B,oBAAW,YAAY,GAAG,CAAE;AAC5B,oBAAW,YAAY,GAAG,GAAI;AAAA,QAE/B;AAAA,MAED,OAAO;AAIN,YAAK,mBAAmB;AAEvB,oBAAW,eAAe,GAAG,CAAE;AAC/B,oBAAW,YAAY,GAAG,CAAE;AAC5B,oBAAW,cAAc,GAAG,GAAI;AAAA,QAEjC,OAAO;AAEN,oBAAW,eAAe,GAAG,CAAE;AAC/B,oBAAW,YAAY,GAAG,CAAE;AAC5B,oBAAW,cAAc,GAAG,GAAI;AAAA,QAEjC;AAAA,MAED;AAAA,IAED;AAEA,qDAAkD,mBAAkB,oBAAoB;AAEvF,UAAK,oBAAoB;AAExB,YAAK,mBAAmB;AAEvB,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAEhC,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAChC,oBAAW,YAAY,IAAI,CAAE;AAE7B,oBAAW,eAAe,IAAI,CAAE;AAChC,oBAAW,cAAc,IAAI,GAAI;AACjC,oBAAW,YAAY,IAAI,CAAE;AAE7B,oBAAW,cAAc,IAAI,GAAI;AACjC,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAAA,QAE9B,OAAO;AAEN,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAEhC,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,eAAe,IAAI,CAAE;AAEhC,oBAAW,eAAe,IAAI,CAAE;AAChC,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,cAAc,IAAI,GAAI;AAEjC,oBAAW,cAAc,IAAI,GAAI;AACjC,oBAAW,YAAY,IAAI,CAAE;AAC7B,oBAAW,YAAY,IAAI,CAAE;AAAA,QAE9B;AAAA,MAED;AAAA,IAED;AAEA,4BAAyB,QAAQ,IAAI,IAAI,mBAAkB,OAAO,GAAI;AAKrE,cAAS,MAAM;AAAA,aAET;AAEJ,cAAK,OAAQ;AAEZ,+BAAoB,QAAQ,IAAI,IAAI,GAAG,GAAI;AAAA,UAE5C,OAAO;AAEN,+BAAoB,QAAQ,IAAI,IAAI,GAAG,GAAI;AAAA,UAE5C;AAEA;AAAA,aAEI;AAEJ,cAAK,OAAQ;AAEZ,qBAAS,WAAY,IAAI,MAAO;AAChC,qBAAS,IAAK,SAAS,GAAG,CAAE,SAAS,CAAE;AAEvC,qBAAS,WAAY,UAAU,QAAS,EAAE,IAAK,MAAO;AACtD,qBAAS,WAAY,UAAU,QAAS,EAAE,IAAK,MAAO;AAGtD,gBAAK,mBAAmB;AAEvB,uBAAS,QAAS,UAAU,IAAI,CAAE;AAClC,uBAAS,QAAS,UAAU,IAAI,CAAE;AAClC,uBAAS,QAAS,UAAU,IAAI,CAAE;AAAA,YAEnC,OAAO;AAEN,uBAAS,QAAS,UAAU,IAAI,CAAE;AAClC,uBAAS,QAAS,UAAU,IAAI,CAAE;AAClC,uBAAS,QAAS,UAAU,IAAI,CAAE;AAAA,YAEnC;AAAA,UAED,OAAO;AAEN,qBAAS,WAAY,IAAI,MAAO;AAChC,qBAAS,IAAK,SAAS,GAAG,CAAE,SAAS,CAAE;AAEvC,qBAAS,WAAY,UAAU,QAAS,EAAE,IAAK,MAAO;AACtD,qBAAS,WAAY,UAAU,QAAS,EAAE,IAAK,MAAO;AAEtD,kBAAM,KAAK,SAAS;AAGpB,gBAAK,mBAAmB;AAEvB,uBAAS,QAAS,UAAU,KAAK,IAAI,CAAE;AACvC,uBAAS,QAAS,UAAU,KAAK,IAAI,CAAE;AACvC,uBAAS,QAAS,UAAU,KAAK,IAAI,CAAE;AAAA,YAExC,OAAO;AAEN,uBAAS,QAAS,UAAU,KAAK,IAAI,CAAE;AACvC,uBAAS,QAAS,UAAU,KAAK,IAAI,CAAE;AACvC,uBAAS,QAAS,UAAU,KAAK,IAAI,CAAE;AAAA,YAExC;AAAA,UAED;AAEA;AAAA,aAEI;AAAA;AAIJ;AAAA;AAAA,IAIH;AAEA,oCAAiC,SAAS;AAKzC,UAAI,YAAY;AAChB,eAAU,IAAI,GAAG,IAAI,QAAO,SAAS,GAAG,IAAI,GAAG,KAAO;AAErD,YAAK,QAAQ,GAAI,WAAY,QAAQ,IAAI,EAAI,IAAI,aAAc;AAE9D,sBAAY;AACZ;AAAA,QAED;AAAA,MAED;AAEA,UAAK,CAAE;AAAY,eAAO;AAE1B,YAAM,YAAY,CAAC;AACnB,gBAAU,KAAM,QAAQ,EAAI;AAE5B,eAAU,IAAI,GAAG,IAAI,QAAO,SAAS,GAAG,IAAI,GAAG,KAAO;AAErD,YAAK,QAAQ,GAAI,WAAY,QAAQ,IAAI,EAAI,KAAK,aAAc;AAE/D,oBAAU,KAAM,QAAQ,EAAI;AAAA,QAE7B;AAAA,MAED;AAEA,gBAAU,KAAM,QAAQ,QAAO,SAAS,EAAI;AAE5C,aAAO;AAAA,IAER;AAAA,EAED;AAGD;;;ACv3FA,IAAM,QAAQ,oBAAI,IAAI;AACtB,IAAM,SAAS,IAAI,UAAU;AAC7B,IAAO,kBAAQ,CAAC,QAAQ,SAAS,OAAO,KAAK,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AAChF,uBAAqB;AACrB,SAAO,KAAK,KAAK,SAAO;AACpB,yBAAqB;AACrB,YAAQ,OAAO,OAAO,GAAG,CAAC;AAAA,EAC9B,GAAG,QAAW,MAAM;AAChB,yBAAqB;AACrB,WAAO;AAAA,EACX,CAAC;AACL,CAAC,CAAC;",
  "names": []
}

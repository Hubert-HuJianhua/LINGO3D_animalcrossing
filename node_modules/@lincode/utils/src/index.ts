export { merge, omit, upperFirst, get, has, unset, range, invert } from "lodash"

export type valueof<T> = T extends ArrayLike<unknown> ? T[number] : T[keyof T]
export type Optional<T, K extends keyof T> = Omit<T, K> & { [k in K]?: T[k] }
export type Callback<Payload = void, ReturnType = void> = (payload: Payload) => ReturnType
export type Class<T = {}> = new (...args: Array<any>) => T
export type RequiredNullable<T, RT = Required<T>> = { [P in keyof RT]: RT[P] | undefined }
export type DeepPartial<T> = { [P in keyof T]?: DeepPartial<T[P]> }

type ForceGet = {
    <Key, Val>(map: Map<Key, Val>, obj: Key, factory: () => Val): Val
    <Key extends object, Val>(map: WeakMap<Key, Val>, obj: Key, factory: () => Val): Val
}

export const forceGet: ForceGet = (map: Map<unknown, unknown> | WeakMap<any, unknown>, obj: unknown, factory: () => unknown) => {
    if (!map.has(obj)) {
        const item = factory()
        map.set(obj, item)
        return item
    }
    return map.get(obj)
}

export const assert = (condition: unknown, msg?: string): asserts condition => {
    if (!condition)
        throw new Error(msg)
}

export const assertExhaustive = (x: never): never => {
    throw new Error("unexpected value: " + x)
} 

export const isInstance = <T extends Class>(target: unknown, ClassVar: T): target is InstanceType<T> => {
    //@ts-ignore
    return target != null && target.constructor === ClassVar
}

export const isNotNullish = <T>(t?: T): t is T => !!t

export const tryParse = <T>(val: unknown, typeGuard?: (val: any) => val is T): T | undefined => {
    if (typeof val !== "string") return

    try {
        const result = JSON.parse(val)
        if (!typeGuard || typeGuard(result))
            return result
    }
    catch {}
}

export const includes = <T>(collection: Set<T> | Map<T, unknown>, value: any): value is T => (
    collection.has(value)
)

export const filter = <T>(obj: T, predicate: (v: valueof<T>, k: keyof T) => boolean) => {
    const result: Partial<T> = {}
    for (const [k, v] of Object.entries(obj))
        predicate(v, k as keyof T) && (result[k as keyof T] = v)

    return result
}

export const omitDeep = <T extends object>(obj: T, keys: ReadonlyArray<string>): T => {
    if (Array.isArray(obj)) {
        const newObj = new Array(obj.length)
        for (let i = 0; i < obj.length; ++i)
            newObj[i] = omitDeep(obj[i], keys)

        return newObj as T
    }
    else if (obj && typeof obj === "object") {
        const newObj: Record<string, any> = {}
        for (const [k, v] of Object.entries(obj))
            !keys.includes(k) && (newObj[k] = omitDeep(v, keys))

        return newObj as T
    }
    return obj
}

export const set = <T extends Record<string, any>>(obj: T, path: Array<string>, value: any) => {
    let target: any = obj
    const iMax = path.length - 1
    for (let i = 0; i < iMax; ++i)
        target = target[path[i]] ??= {}

    target[path[iMax]] = value
}

export const traverse = (
    obj: unknown,
    cb: (k: string | number, v: any, parent: Record<any, any> | Array<any>) => void,
    traversed = new WeakSet()
) => {
    if (Array.isArray(obj)) {
        if (traversed.has(obj)) return
        traversed.add(obj)

        for (let i = 0; i < obj.length; ++i) {
            const v = obj[i]
            cb(i, v, obj)
            traverse(v, cb, traversed)
        }
    }
    else if (obj && typeof obj === "object") {
        if (traversed.has(obj)) return
        traversed.add(obj)

        for (const [k, v] of Object.entries(obj)) {
            cb(k, v, obj)
            traverse(v, cb, traversed)
        }
    }
}

export const everyAsFirst = <T>(array: Array<T>, predicate: (item: T, first: T) => any) => {
    if (array.length === 0) return false
    const firstItem = array[0]
    const firstResult = predicate(firstItem, firstItem)
    return array.every(item => predicate(item, firstItem) === firstResult)
}

export const keepOne = <T>(items?: Array<T>): Array<T> => items?.length ? [items[0]] : []

export const pull = <T>(array: Array<T>, item: T): boolean => {
    const index = array.indexOf(item)
    if (index === -1) return false
    array.splice(index, 1)
    return true
}

export const insert = <T>(array: Array<T>, item: T, index: number) => {
    array.splice(index, 0, item)
}

export const dedupe = <T>(array: Array<T>) => [...new Set(array)]

type Last = {
    (val: string, index?: number): string | undefined
    <T>(val: Array<T>, index?: number): T | undefined
}

export const last: Last = (val: string | Array<any>, index = -1) => val[val.length + index]

export const replaceAll = (val: string, from: string, to: string): string => {
    return val.split(from).join(to)
}

export const trim = (str: string, char: string) => {
    if (char === "]") char = "\\]"
    if (char === "\\") char = "\\\\"
    return str.replace(new RegExp("^[" + char + "]+|[" + char + "]+$", "g"), "")
}

export const between = (s: string, char0: string, char1: string): string => {
    const i0 = s.indexOf(char0)
    if (i0 === -1) return ""

    const indexStart = i0 + char0.length
    
    const i1 = s.indexOf(char1, indexStart)
    if (i1 === -1) return ""

    return s.substring(indexStart, i1)
}

export const splitFileName = (fileName: string): [string, string?] => {
    const parts = fileName.split(".")

    if (parts.length === 1)
        return parts as [string]

    const extension = parts.pop()
    return [parts.join("."), extension]
}

export const random = (min: number, max: number) => {
    return (Math.random() * (max - min)) + min
}

type Edge = "leading" | "trailing" | "both" | "trailingPromise"

type Throttle = {
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "leading" | "both"): (...args: Args) => Result
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailing"): (...args: Args) => Result | undefined
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailingPromise"): (...args: Args) => Promise<Result>
}

export const throttle: Throttle = <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: Edge) => {
    let result: Result
    let blocked = false
    let args0: Args

    let resultResolve: ((val: Result | PromiseLike<Result>) => void) | undefined = undefined
    let resultPromise = edge === "trailingPromise" ? new Promise<Result>(r => resultResolve = r) : undefined

    return function (this: unknown, ...args: Args) {
        args0 = args

        if (blocked) return resultPromise ?? result
        blocked = true

        if (edge === "leading" || edge === "both")
            result = fn.apply(this, args0)

        const cb = () => {
            if (edge === "trailing" || edge === "both" || edge === "trailingPromise") {
                result = fn.apply(this, args0)
                resultResolve?.(result)
                resultPromise = edge === "trailingPromise" ? new Promise<Result>(r => resultResolve = r) : undefined
            }
            blocked = false
        }
        timeout > 0 ? setTimeout(cb, timeout) : queueMicrotask(cb)

        return resultPromise ?? result
    }
}

const cancellableTimeout = (cb: () => void, time: number): () => void => {
    if (time === 0) {
        let signal = true
        queueMicrotask(() => signal && cb())
        return () => signal = false
    }
    const t = setTimeout(cb, time)
    return () => clearTimeout(t)
}

type Debounce = {
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "leading" | "both"): (...args: Args) => Result
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailing"): (...args: Args) => Result | undefined
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailingPromise"): (...args: Args) => Promise<Result>
}

export const debounce: Debounce = <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: Edge) => {
    let cancelTimeout: (() => void) | undefined
    let result: Result
    let args0: Args

    let resultResolve: ((val: Result | PromiseLike<Result>) => void) | undefined = undefined
    let resultPromise = edge === "trailingPromise" ? new Promise<Result>(r => resultResolve = r) : undefined

    return function(this: unknown, ...args: Args) {  
        args0 = args

        if (cancelTimeout)
            cancelTimeout()
        else if (edge === "leading" || edge === "both")
            result = fn.apply(this, args0)

        cancelTimeout = cancellableTimeout(() => {
            if (edge === "trailing" || edge === "both" || edge === "trailingPromise") {
                result = fn.apply(this, args0)
                resultResolve?.(result)
                resultPromise = edge === "trailingPromise" ? new Promise<Result>(r => resultResolve = r) : undefined
            }
            cancelTimeout = undefined

        }, timeout)

        return resultPromise ?? result
    }
}

export const isAssignable = (SubClass: Class, SuperClass: Class): boolean => {
    return SubClass === SuperClass || SubClass.prototype instanceof SuperClass
}

export const getMethods = (obj: object | null) => {
    const methods = new Set<string>()
    while (obj) {
        for (const key of Reflect.ownKeys(obj))
            typeof key === "string" && methods.add(key)

        obj = Reflect.getPrototypeOf(obj)
    }
    return [...methods]
}

export const log = <T>(val: T) => (console.log(val), val)

export const type = <T>(val: T) => val

const functionExtendedMap = new WeakMap<Function, Array<Function>>()

export const extendFunction = <T extends Function>(fn: T | undefined, target: T): T => {
    function extended(this: unknown) {
        let result: unknown
        for (const cb of callbacks) {
            const res = cb.apply(this, arguments)
            if (result === undefined) result = res
        }
        return result
    }
    const existingCallbacks = fn ? forceGet(functionExtendedMap, fn, () => [fn]) : []
    const callbacks = [...existingCallbacks, target]
    functionExtendedMap.set(extended, callbacks)

    //@ts-ignore
    return extended
}

export const omitFunction = <T extends Function>(fn: T, target: T): T => {
    function extended(this: unknown) {
        let result: unknown
        for (const cb of callbacks) {
            const res = cb.apply(this, arguments)
            if (result === undefined) result = res
        }
        return result
    }
    const existingCallbacks = forceGet(functionExtendedMap, fn, () => [fn])
    const callbacks = existingCallbacks.filter(f => f !== target)
    functionExtendedMap.set(extended, callbacks)

    //@ts-ignore
    return extended
}

export const lazy = <T, Args extends Array<any>>(factory: (...a: Args) => T, invalidateWhenReturnValueChanges?: () => any): (...a: Args) => T => {
    let result: T
    let has = false
    let valOld = invalidateWhenReturnValueChanges?.()

    return (...a: Args): T => {
        if (invalidateWhenReturnValueChanges) {
            const val = invalidateWhenReturnValueChanges()
            valOld !== val && (has = false)
            valOld = val
        }
        if (has) return result
        has = true
        return result = factory(...a)
    }
}

export const applyMixins = (toClass: any, fromClasses: Array<any>) => {
    for (const fromClass of fromClasses)
        for (const name of Object.getOwnPropertyNames(fromClass.prototype))
            Object.defineProperty(
                toClass.prototype,
                name,
                Object.getOwnPropertyDescriptor(fromClass.prototype, name) ||
                Object.create(null)
            )
}

export const preventTreeShake = <T>(obj: T) => obj
export { merge, omit, upperFirst, get, has, unset, range, invert } from "lodash";
export declare type valueof<T> = T extends ArrayLike<unknown> ? T[number] : T[keyof T];
export declare type Optional<T, K extends keyof T> = Omit<T, K> & {
    [k in K]?: T[k];
};
export declare type Callback<Payload = void, ReturnType = void> = (payload: Payload) => ReturnType;
export declare type Class<T = {}> = new (...args: Array<any>) => T;
export declare type RequiredNullable<T, RT = Required<T>> = {
    [P in keyof RT]: RT[P] | undefined;
};
export declare type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
declare type ForceGet = {
    <Key, Val>(map: Map<Key, Val>, obj: Key, factory: () => Val): Val;
    <Key extends object, Val>(map: WeakMap<Key, Val>, obj: Key, factory: () => Val): Val;
};
export declare const forceGet: ForceGet;
export declare const assert: (condition: unknown, msg?: string | undefined) => asserts condition;
export declare const assertExhaustive: (x: never) => never;
export declare const isInstance: <T extends Class<{}>>(target: unknown, ClassVar: T) => target is InstanceType<T>;
export declare const isNotNullish: <T>(t?: T | undefined) => t is T;
export declare const tryParse: <T>(val: unknown, typeGuard?: ((val: any) => val is T) | undefined) => T | undefined;
export declare const includes: <T>(collection: Set<T> | Map<T, unknown>, value: any) => value is T;
export declare const filter: <T>(obj: T, predicate: (v: valueof<T>, k: keyof T) => boolean) => Partial<T>;
export declare const omitDeep: <T extends object>(obj: T, keys: ReadonlyArray<string>) => T;
export declare const set: <T extends Record<string, any>>(obj: T, path: Array<string>, value: any) => void;
export declare const traverse: (obj: unknown, cb: (k: string | number, v: any, parent: Record<any, any> | Array<any>) => void, traversed?: WeakSet<object>) => void;
export declare const everyAsFirst: <T>(array: T[], predicate: (item: T, first: T) => any) => boolean;
export declare const keepOne: <T>(items?: T[] | undefined) => T[];
export declare const pull: <T>(array: T[], item: T) => boolean;
export declare const insert: <T>(array: T[], item: T, index: number) => void;
export declare const dedupe: <T>(array: T[]) => T[];
declare type Last = {
    (val: string, index?: number): string | undefined;
    <T>(val: Array<T>, index?: number): T | undefined;
};
export declare const last: Last;
export declare const replaceAll: (val: string, from: string, to: string) => string;
export declare const trim: (str: string, char: string) => string;
export declare const between: (s: string, char0: string, char1: string) => string;
export declare const splitFileName: (fileName: string) => [string, string?];
export declare const random: (min: number, max: number) => number;
declare type Throttle = {
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "leading" | "both"): (...args: Args) => Result;
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailing"): (...args: Args) => Result | undefined;
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailingPromise"): (...args: Args) => Promise<Result>;
};
export declare const throttle: Throttle;
declare type Debounce = {
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "leading" | "both"): (...args: Args) => Result;
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailing"): (...args: Args) => Result | undefined;
    <Args extends Array<unknown>, Result>(fn: (...args: Args) => Result, timeout: number, edge: "trailingPromise"): (...args: Args) => Promise<Result>;
};
export declare const debounce: Debounce;
export declare const isAssignable: (SubClass: Class, SuperClass: Class) => boolean;
export declare const getMethods: (obj: object | null) => string[];
export declare const log: <T>(val: T) => T;
export declare const type: <T>(val: T) => T;
export declare const extendFunction: <T extends Function>(fn: T | undefined, target: T) => T;
export declare const omitFunction: <T extends Function>(fn: T, target: T) => T;
export declare const lazy: <T, Args extends any[]>(factory: (...a: Args) => T, invalidateWhenReturnValueChanges?: (() => any) | undefined) => (...a: Args) => T;
export declare const applyMixins: (toClass: any, fromClasses: Array<any>) => void;
export declare const preventTreeShake: <T>(obj: T) => T;

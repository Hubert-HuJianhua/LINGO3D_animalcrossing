export { merge, omit, upperFirst, get, has, unset, range, invert } from "lodash";
export const forceGet = (map, obj, factory) => {
    if (!map.has(obj)) {
        const item = factory();
        map.set(obj, item);
        return item;
    }
    return map.get(obj);
};
export const assert = (condition, msg) => {
    if (!condition)
        throw new Error(msg);
};
export const assertExhaustive = (x) => {
    throw new Error("unexpected value: " + x);
};
export const isInstance = (target, ClassVar) => {
    //@ts-ignore
    return target != null && target.constructor === ClassVar;
};
export const isNotNullish = (t) => !!t;
export const tryParse = (val, typeGuard) => {
    if (typeof val !== "string")
        return;
    try {
        const result = JSON.parse(val);
        if (!typeGuard || typeGuard(result))
            return result;
    }
    catch { }
};
export const includes = (collection, value) => (collection.has(value));
export const filter = (obj, predicate) => {
    const result = {};
    for (const [k, v] of Object.entries(obj))
        predicate(v, k) && (result[k] = v);
    return result;
};
export const omitDeep = (obj, keys) => {
    if (Array.isArray(obj)) {
        const newObj = new Array(obj.length);
        for (let i = 0; i < obj.length; ++i)
            newObj[i] = omitDeep(obj[i], keys);
        return newObj;
    }
    else if (obj && typeof obj === "object") {
        const newObj = {};
        for (const [k, v] of Object.entries(obj))
            !keys.includes(k) && (newObj[k] = omitDeep(v, keys));
        return newObj;
    }
    return obj;
};
export const set = (obj, path, value) => {
    var _a;
    var _b;
    let target = obj;
    const iMax = path.length - 1;
    for (let i = 0; i < iMax; ++i)
        target = (_a = target[_b = path[i]]) !== null && _a !== void 0 ? _a : (target[_b] = {});
    target[path[iMax]] = value;
};
export const traverse = (obj, cb, traversed = new WeakSet()) => {
    if (Array.isArray(obj)) {
        if (traversed.has(obj))
            return;
        traversed.add(obj);
        for (let i = 0; i < obj.length; ++i) {
            const v = obj[i];
            cb(i, v, obj);
            traverse(v, cb, traversed);
        }
    }
    else if (obj && typeof obj === "object") {
        if (traversed.has(obj))
            return;
        traversed.add(obj);
        for (const [k, v] of Object.entries(obj)) {
            cb(k, v, obj);
            traverse(v, cb, traversed);
        }
    }
};
export const everyAsFirst = (array, predicate) => {
    if (array.length === 0)
        return false;
    const firstItem = array[0];
    const firstResult = predicate(firstItem, firstItem);
    return array.every(item => predicate(item, firstItem) === firstResult);
};
export const keepOne = (items) => (items === null || items === void 0 ? void 0 : items.length) ? [items[0]] : [];
export const pull = (array, item) => {
    const index = array.indexOf(item);
    if (index === -1)
        return false;
    array.splice(index, 1);
    return true;
};
export const insert = (array, item, index) => {
    array.splice(index, 0, item);
};
export const dedupe = (array) => [...new Set(array)];
export const last = (val, index = -1) => val[val.length + index];
export const replaceAll = (val, from, to) => {
    return val.split(from).join(to);
};
export const trim = (str, char) => {
    if (char === "]")
        char = "\\]";
    if (char === "\\")
        char = "\\\\";
    return str.replace(new RegExp("^[" + char + "]+|[" + char + "]+$", "g"), "");
};
export const between = (s, char0, char1) => {
    const i0 = s.indexOf(char0);
    if (i0 === -1)
        return "";
    const indexStart = i0 + char0.length;
    const i1 = s.indexOf(char1, indexStart);
    if (i1 === -1)
        return "";
    return s.substring(indexStart, i1);
};
export const splitFileName = (fileName) => {
    const parts = fileName.split(".");
    if (parts.length === 1)
        return parts;
    const extension = parts.pop();
    return [parts.join("."), extension];
};
export const random = (min, max) => {
    return (Math.random() * (max - min)) + min;
};
export const throttle = (fn, timeout, edge) => {
    let result;
    let blocked = false;
    let args0;
    let resultResolve = undefined;
    let resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
    return function (...args) {
        args0 = args;
        if (blocked)
            return resultPromise !== null && resultPromise !== void 0 ? resultPromise : result;
        blocked = true;
        if (edge === "leading" || edge === "both")
            result = fn.apply(this, args0);
        const cb = () => {
            if (edge === "trailing" || edge === "both" || edge === "trailingPromise") {
                result = fn.apply(this, args0);
                resultResolve === null || resultResolve === void 0 ? void 0 : resultResolve(result);
                resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
            }
            blocked = false;
        };
        timeout > 0 ? setTimeout(cb, timeout) : queueMicrotask(cb);
        return resultPromise !== null && resultPromise !== void 0 ? resultPromise : result;
    };
};
const cancellableTimeout = (cb, time) => {
    if (time === 0) {
        let signal = true;
        queueMicrotask(() => signal && cb());
        return () => signal = false;
    }
    const t = setTimeout(cb, time);
    return () => clearTimeout(t);
};
export const debounce = (fn, timeout, edge) => {
    let cancelTimeout;
    let result;
    let args0;
    let resultResolve = undefined;
    let resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
    return function (...args) {
        args0 = args;
        if (cancelTimeout)
            cancelTimeout();
        else if (edge === "leading" || edge === "both")
            result = fn.apply(this, args0);
        cancelTimeout = cancellableTimeout(() => {
            if (edge === "trailing" || edge === "both" || edge === "trailingPromise") {
                result = fn.apply(this, args0);
                resultResolve === null || resultResolve === void 0 ? void 0 : resultResolve(result);
                resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
            }
            cancelTimeout = undefined;
        }, timeout);
        return resultPromise !== null && resultPromise !== void 0 ? resultPromise : result;
    };
};
export const isAssignable = (SubClass, SuperClass) => {
    return SubClass === SuperClass || SubClass.prototype instanceof SuperClass;
};
export const getMethods = (obj) => {
    const methods = new Set();
    while (obj) {
        for (const key of Reflect.ownKeys(obj))
            typeof key === "string" && methods.add(key);
        obj = Reflect.getPrototypeOf(obj);
    }
    return [...methods];
};
export const log = (val) => (console.log(val), val);
export const type = (val) => val;
const functionExtendedMap = new WeakMap();
export const extendFunction = (fn, target) => {
    function extended() {
        let result;
        for (const cb of callbacks) {
            const res = cb.apply(this, arguments);
            if (result === undefined)
                result = res;
        }
        return result;
    }
    const existingCallbacks = fn ? forceGet(functionExtendedMap, fn, () => [fn]) : [];
    const callbacks = [...existingCallbacks, target];
    functionExtendedMap.set(extended, callbacks);
    //@ts-ignore
    return extended;
};
export const omitFunction = (fn, target) => {
    function extended() {
        let result;
        for (const cb of callbacks) {
            const res = cb.apply(this, arguments);
            if (result === undefined)
                result = res;
        }
        return result;
    }
    const existingCallbacks = forceGet(functionExtendedMap, fn, () => [fn]);
    const callbacks = existingCallbacks.filter(f => f !== target);
    functionExtendedMap.set(extended, callbacks);
    //@ts-ignore
    return extended;
};
export const lazy = (factory, invalidateWhenReturnValueChanges) => {
    let result;
    let has = false;
    let valOld = invalidateWhenReturnValueChanges === null || invalidateWhenReturnValueChanges === void 0 ? void 0 : invalidateWhenReturnValueChanges();
    return (...a) => {
        if (invalidateWhenReturnValueChanges) {
            const val = invalidateWhenReturnValueChanges();
            valOld !== val && (has = false);
            valOld = val;
        }
        if (has)
            return result;
        has = true;
        return result = factory(...a);
    };
};
export const applyMixins = (toClass, fromClasses) => {
    for (const fromClass of fromClasses)
        for (const name of Object.getOwnPropertyNames(fromClass.prototype))
            Object.defineProperty(toClass.prototype, name, Object.getOwnPropertyDescriptor(fromClass.prototype, name) ||
                Object.create(null));
};
export const preventTreeShake = (obj) => obj;

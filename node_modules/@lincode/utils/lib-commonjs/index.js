"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preventTreeShake = exports.applyMixins = exports.lazy = exports.omitFunction = exports.extendFunction = exports.type = exports.log = exports.getMethods = exports.isAssignable = exports.debounce = exports.throttle = exports.random = exports.splitFileName = exports.between = exports.trim = exports.replaceAll = exports.last = exports.dedupe = exports.insert = exports.pull = exports.keepOne = exports.everyAsFirst = exports.traverse = exports.set = exports.omitDeep = exports.filter = exports.includes = exports.tryParse = exports.isNotNullish = exports.isInstance = exports.assertExhaustive = exports.assert = exports.forceGet = exports.invert = exports.range = exports.unset = exports.has = exports.get = exports.upperFirst = exports.omit = exports.merge = void 0;
var lodash_1 = require("lodash");
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return lodash_1.merge; } });
Object.defineProperty(exports, "omit", { enumerable: true, get: function () { return lodash_1.omit; } });
Object.defineProperty(exports, "upperFirst", { enumerable: true, get: function () { return lodash_1.upperFirst; } });
Object.defineProperty(exports, "get", { enumerable: true, get: function () { return lodash_1.get; } });
Object.defineProperty(exports, "has", { enumerable: true, get: function () { return lodash_1.has; } });
Object.defineProperty(exports, "unset", { enumerable: true, get: function () { return lodash_1.unset; } });
Object.defineProperty(exports, "range", { enumerable: true, get: function () { return lodash_1.range; } });
Object.defineProperty(exports, "invert", { enumerable: true, get: function () { return lodash_1.invert; } });
const forceGet = (map, obj, factory) => {
    if (!map.has(obj)) {
        const item = factory();
        map.set(obj, item);
        return item;
    }
    return map.get(obj);
};
exports.forceGet = forceGet;
const assert = (condition, msg) => {
    if (!condition)
        throw new Error(msg);
};
exports.assert = assert;
const assertExhaustive = (x) => {
    throw new Error("unexpected value: " + x);
};
exports.assertExhaustive = assertExhaustive;
const isInstance = (target, ClassVar) => {
    //@ts-ignore
    return target != null && target.constructor === ClassVar;
};
exports.isInstance = isInstance;
const isNotNullish = (t) => !!t;
exports.isNotNullish = isNotNullish;
const tryParse = (val, typeGuard) => {
    if (typeof val !== "string")
        return;
    try {
        const result = JSON.parse(val);
        if (!typeGuard || typeGuard(result))
            return result;
    }
    catch { }
};
exports.tryParse = tryParse;
const includes = (collection, value) => (collection.has(value));
exports.includes = includes;
const filter = (obj, predicate) => {
    const result = {};
    for (const [k, v] of Object.entries(obj))
        predicate(v, k) && (result[k] = v);
    return result;
};
exports.filter = filter;
const omitDeep = (obj, keys) => {
    if (Array.isArray(obj)) {
        const newObj = new Array(obj.length);
        for (let i = 0; i < obj.length; ++i)
            newObj[i] = (0, exports.omitDeep)(obj[i], keys);
        return newObj;
    }
    else if (obj && typeof obj === "object") {
        const newObj = {};
        for (const [k, v] of Object.entries(obj))
            !keys.includes(k) && (newObj[k] = (0, exports.omitDeep)(v, keys));
        return newObj;
    }
    return obj;
};
exports.omitDeep = omitDeep;
const set = (obj, path, value) => {
    var _a;
    var _b;
    let target = obj;
    const iMax = path.length - 1;
    for (let i = 0; i < iMax; ++i)
        target = (_a = target[_b = path[i]]) !== null && _a !== void 0 ? _a : (target[_b] = {});
    target[path[iMax]] = value;
};
exports.set = set;
const traverse = (obj, cb, traversed = new WeakSet()) => {
    if (Array.isArray(obj)) {
        if (traversed.has(obj))
            return;
        traversed.add(obj);
        for (let i = 0; i < obj.length; ++i) {
            const v = obj[i];
            cb(i, v, obj);
            (0, exports.traverse)(v, cb, traversed);
        }
    }
    else if (obj && typeof obj === "object") {
        if (traversed.has(obj))
            return;
        traversed.add(obj);
        for (const [k, v] of Object.entries(obj)) {
            cb(k, v, obj);
            (0, exports.traverse)(v, cb, traversed);
        }
    }
};
exports.traverse = traverse;
const everyAsFirst = (array, predicate) => {
    if (array.length === 0)
        return false;
    const firstItem = array[0];
    const firstResult = predicate(firstItem, firstItem);
    return array.every(item => predicate(item, firstItem) === firstResult);
};
exports.everyAsFirst = everyAsFirst;
const keepOne = (items) => (items === null || items === void 0 ? void 0 : items.length) ? [items[0]] : [];
exports.keepOne = keepOne;
const pull = (array, item) => {
    const index = array.indexOf(item);
    if (index === -1)
        return false;
    array.splice(index, 1);
    return true;
};
exports.pull = pull;
const insert = (array, item, index) => {
    array.splice(index, 0, item);
};
exports.insert = insert;
const dedupe = (array) => [...new Set(array)];
exports.dedupe = dedupe;
const last = (val, index = -1) => val[val.length + index];
exports.last = last;
const replaceAll = (val, from, to) => {
    return val.split(from).join(to);
};
exports.replaceAll = replaceAll;
const trim = (str, char) => {
    if (char === "]")
        char = "\\]";
    if (char === "\\")
        char = "\\\\";
    return str.replace(new RegExp("^[" + char + "]+|[" + char + "]+$", "g"), "");
};
exports.trim = trim;
const between = (s, char0, char1) => {
    const i0 = s.indexOf(char0);
    if (i0 === -1)
        return "";
    const indexStart = i0 + char0.length;
    const i1 = s.indexOf(char1, indexStart);
    if (i1 === -1)
        return "";
    return s.substring(indexStart, i1);
};
exports.between = between;
const splitFileName = (fileName) => {
    const parts = fileName.split(".");
    if (parts.length === 1)
        return parts;
    const extension = parts.pop();
    return [parts.join("."), extension];
};
exports.splitFileName = splitFileName;
const random = (min, max) => {
    return (Math.random() * (max - min)) + min;
};
exports.random = random;
const throttle = (fn, timeout, edge) => {
    let result;
    let blocked = false;
    let args0;
    let resultResolve = undefined;
    let resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
    return function (...args) {
        args0 = args;
        if (blocked)
            return resultPromise !== null && resultPromise !== void 0 ? resultPromise : result;
        blocked = true;
        if (edge === "leading" || edge === "both")
            result = fn.apply(this, args0);
        const cb = () => {
            if (edge === "trailing" || edge === "both" || edge === "trailingPromise") {
                result = fn.apply(this, args0);
                resultResolve === null || resultResolve === void 0 ? void 0 : resultResolve(result);
                resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
            }
            blocked = false;
        };
        timeout > 0 ? setTimeout(cb, timeout) : queueMicrotask(cb);
        return resultPromise !== null && resultPromise !== void 0 ? resultPromise : result;
    };
};
exports.throttle = throttle;
const cancellableTimeout = (cb, time) => {
    if (time === 0) {
        let signal = true;
        queueMicrotask(() => signal && cb());
        return () => signal = false;
    }
    const t = setTimeout(cb, time);
    return () => clearTimeout(t);
};
const debounce = (fn, timeout, edge) => {
    let cancelTimeout;
    let result;
    let args0;
    let resultResolve = undefined;
    let resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
    return function (...args) {
        args0 = args;
        if (cancelTimeout)
            cancelTimeout();
        else if (edge === "leading" || edge === "both")
            result = fn.apply(this, args0);
        cancelTimeout = cancellableTimeout(() => {
            if (edge === "trailing" || edge === "both" || edge === "trailingPromise") {
                result = fn.apply(this, args0);
                resultResolve === null || resultResolve === void 0 ? void 0 : resultResolve(result);
                resultPromise = edge === "trailingPromise" ? new Promise(r => resultResolve = r) : undefined;
            }
            cancelTimeout = undefined;
        }, timeout);
        return resultPromise !== null && resultPromise !== void 0 ? resultPromise : result;
    };
};
exports.debounce = debounce;
const isAssignable = (SubClass, SuperClass) => {
    return SubClass === SuperClass || SubClass.prototype instanceof SuperClass;
};
exports.isAssignable = isAssignable;
const getMethods = (obj) => {
    const methods = new Set();
    while (obj) {
        for (const key of Reflect.ownKeys(obj))
            typeof key === "string" && methods.add(key);
        obj = Reflect.getPrototypeOf(obj);
    }
    return [...methods];
};
exports.getMethods = getMethods;
const log = (val) => (console.log(val), val);
exports.log = log;
const type = (val) => val;
exports.type = type;
const functionExtendedMap = new WeakMap();
const extendFunction = (fn, target) => {
    function extended() {
        let result;
        for (const cb of callbacks) {
            const res = cb.apply(this, arguments);
            if (result === undefined)
                result = res;
        }
        return result;
    }
    const existingCallbacks = fn ? (0, exports.forceGet)(functionExtendedMap, fn, () => [fn]) : [];
    const callbacks = [...existingCallbacks, target];
    functionExtendedMap.set(extended, callbacks);
    //@ts-ignore
    return extended;
};
exports.extendFunction = extendFunction;
const omitFunction = (fn, target) => {
    function extended() {
        let result;
        for (const cb of callbacks) {
            const res = cb.apply(this, arguments);
            if (result === undefined)
                result = res;
        }
        return result;
    }
    const existingCallbacks = (0, exports.forceGet)(functionExtendedMap, fn, () => [fn]);
    const callbacks = existingCallbacks.filter(f => f !== target);
    functionExtendedMap.set(extended, callbacks);
    //@ts-ignore
    return extended;
};
exports.omitFunction = omitFunction;
const lazy = (factory, invalidateWhenReturnValueChanges) => {
    let result;
    let has = false;
    let valOld = invalidateWhenReturnValueChanges === null || invalidateWhenReturnValueChanges === void 0 ? void 0 : invalidateWhenReturnValueChanges();
    return (...a) => {
        if (invalidateWhenReturnValueChanges) {
            const val = invalidateWhenReturnValueChanges();
            valOld !== val && (has = false);
            valOld = val;
        }
        if (has)
            return result;
        has = true;
        return result = factory(...a);
    };
};
exports.lazy = lazy;
const applyMixins = (toClass, fromClasses) => {
    for (const fromClass of fromClasses)
        for (const name of Object.getOwnPropertyNames(fromClass.prototype))
            Object.defineProperty(toClass.prototype, name, Object.getOwnPropertyDescriptor(fromClass.prototype, name) ||
                Object.create(null));
};
exports.applyMixins = applyMixins;
const preventTreeShake = (obj) => obj;
exports.preventTreeShake = preventTreeShake;

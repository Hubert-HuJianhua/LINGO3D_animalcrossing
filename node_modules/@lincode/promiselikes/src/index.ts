import { Callback, pull } from "@lincode/utils"

abstract class Thenable<T> implements PromiseLike<T> {
    public done?: boolean = undefined
    private _value?: T = undefined
    private _callbacks?: Set<Callback<T>> = undefined
    private _watched?: Set<Thenable<T>> = undefined

    public constructor(
        private _cb: Callback<T> | undefined = undefined
    ) {}

    public then(cb: Callback<T>): Cancellable
    public then(cb: Callback<T>): Cancellable
    public then(cb: Callback<T>): Cancellable {
        if (this.done) {
            cb(this._value!)
            return new Cancellable()
        }
        ;(this._callbacks ??= new Set()).add(cb)
        return new Cancellable(() => this._callbacks!.delete(cb))
    }

    public watch<Item extends Thenable<T>>(item: Item): Item {
        if (this.done)
            return item._resolve(this._value!)

        ;(this._watched ??= new Set()).add(item)
        item.then(() => this._watched!.delete(item))
        
        return item
    }

    protected _resolve(val: T): this {
        if (this.done)
            return this

        this.done = true
        this._value = val

        this._cb?.(val)

        if (this._callbacks)
            for (const cb of this._callbacks)
                cb(val)

        if (this._watched)
            for (const item of this._watched)
                item._resolve(val)

        return this
    }
}

export class Resolvable<T = void> extends Thenable<T> {
    public constructor(cb?: Callback<T>) {
        super(cb)
    }

    public resolve(val: T): this {
        return this._resolve(val)
    }
}

export class Cancellable<T = void> extends Thenable<T> {
    public constructor(cb?: Callback<T>) {
        super(cb)
    }

    public cancel(val: T): this {
        return this._resolve(val)
    }
}

export class Disposable<T = void> extends Thenable<T> {
    public constructor(cb?: Callback<T>) {
        super(cb)
    }

    public dispose(val: T): this {
        return this._resolve(val)
    }
}

const cancelled = new Cancellable().cancel()

export class Queue {
    private queue: Array<() => void> = []
    private count = 0

    public then(cb: () => void) {
        if ((this.count++) === 0) {
            cb()
            return cancelled
        }
        this.queue.push(cb)
        return new Cancellable(() => pull(this.queue, cb))
    }

    public resolve() {
        this.count--
        this.queue.shift()?.()
        return this
    }
}